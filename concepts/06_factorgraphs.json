{
  "name" : "Factor Graphs",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "code" : "When optimizing by inference, Wolfe first factorizes the objective and then\ncreates a [Factor Graph](http://en.wikipedia.org/wiki/Factor_graph) to represent the problem internally.\nThis is a bipartite graph with 'variable nodes' to represent each of the atomic variables in the space and\n'factor nodes' to represent each of the factors in the objective.\n",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 1,
    "compiler" : "wolfe",
    "input" : {
      "code" : "case class Data(x:Int, y:Int, z:Boolean)\ndef space = all(Data) {(1 to 3) x (1 to 3) x bools}\n\n@OutputFactorGraph\ndef model(d:Data) = I(d.x > 1 || d.z) + d.x + 2*d.x*d.y\nval b = argmax(space) {model}\n\nFactorGraphBuffer.get",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "code" : "This graph can then be used for message passing algorithms such as\n[Max/Sum Product](http://en.wikipedia.org/wiki/Belief_propagation), in which information is propagated\nthrough the graph by passing 'messages' along the eges between factors and variables.\n\nIf the generated factor graph contains loops, then these message passing algorithms may only yield\nan approximate solution. In this case, Wolfe also supports exact inference by using the\n[Junction Tree Algorithm](http://en.wikipedia.org/wiki/Junction_tree). This creates a tree from the original factor\ngraph, reducing groups of variables down to a single composite node so that the resulting graph\ncontains no loops.",
      "outputFormat" : "html",
      "extraFields" : null
    }
  } ]
}
