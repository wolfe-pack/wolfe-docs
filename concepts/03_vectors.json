{
  "name" : "Vectors",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "code" : "Vectors play a crucial role in Wolfe and are used to parametrize models over possible worlds. \nThat is, many models \\\\(f\\\\) have parameter \\\\(\\mathbf{w}\\\\) that controls\nthe behaviour of the function. For example, a large number of Machine Learning\nmodels are linear:\n\\\\[\nf_\\mathbf{w}(s) = \\left<\\mathbf{w}, \\boldsymbol{\\phi}(s)\\right>\n\\\\]\nOften these parameters are learned from data. \n\nWolfe `Vector` objects are particular in the sense that their indices aren't just\nintegers, they can be any Scala objects. In Wolfe such vectors are implemented \nas immutable maps from [Any](http://www.scala-lang.org/api/2.10.3/index.html#scala.Any)\nto real numbers, with a default value of `0.0` for undefined indices. \nThis means that clients do not need to explicitly define a vector domain. \n\nNote that internally Wolfe compiles such vectors to more efficient \ninteger-indexed representations. ",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 1,
    "compiler" : "heading3",
    "input" : {
      "code" : "Constructing Vectors",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "code" : "Wolfe provides two ways to construct vectors: through a direct constructor and\nas sums of one-hot vectors. \n\nThe direct constructor has the same shape as the `Map` constructor in Scala where\na sequence of key-value pairs is provided, with the constraint that \nthe value has to be a double.\n\n\n",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 3,
    "compiler" : "wolfe",
    "input" : {
      "code" : "val v = Vector('A -> 0.3, 2 -> -2.0, 'A -> 3 -> 3.5)\nv('A) == 0.3 && v('A->3) == 3.5 && v('B) == 0.0",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 4,
    "compiler" : "markdown",
    "input" : {
      "code" : "One-hot vectors are vectors with value 0 for all but one index. One could\nconstruct such a vector also using the direct constructor, but \n `oneHot` assumes `1.0` as value by default, and hence in many cases one\n can omit the value, leading to a more compact representation.",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 5,
    "compiler" : "wolfe",
    "input" : {
      "code" : "val w = oneHot('someIndex->\"canBeAnything\")\nw == Vector('someIndex->\"canBeAnything\"->1.0)",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 6,
    "compiler" : "markdown",
    "input" : {
      "code" : "One-hot vectors are particularly useful when constructing feature representations\nof possible worlds that factorize into feature representations\nof its constituents. \n",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 7,
    "compiler" : "wolfe",
    "input" : {
      "code" : "case class Document(words:Seq[String],label:String)\ndef feats(d:Document) = \n  sum(0 until d.words.size) {i => oneHot('w->d.words(i))}\nfeats(Document(Seq(\"the\",\"scorer\",\"scored\"),\"sports\"))",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 8,
    "compiler" : "heading3",
    "input" : {
      "code" : "Conjunctions",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 9,
    "compiler" : "markdown",
    "input" : {
      "code" : "Feature representations of possible worlds are constructed hierarchically: one \nextracts features from parts of the world, and then conjoins them to capture \ninteractions between the parts. For example, for a token labelling problem\nwe extract a representation for the token and its context, and one for the label.\nThe representation of the complete world is then uses pairs of token and label\nfeatures as new features. Wolfe provides the `outer` or `x` operator on vectors\nto enable such conjunctions. ",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 10,
    "compiler" : "wolfe",
    "input" : {
      "code" : "case class Token(word:String,pos:String)\ndef wordFeats(word:String) =\n  oneHot('word -> word, 1.0) +\n  oneHot('upper, if (word(0).isUpper) 1.0 else 0.0)\ndef posFeats(pos:String) = \n  oneHot('pos -> pos)\nwordFeats(\"house\") outer posFeats(\"noun\")",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 11,
    "compiler" : "markdown",
    "input" : {
      "code" : "Note that `outer` corresponds to an outer product of two vectors. This is most obvious when\nuses integer-indexed vectors, as shown below. This also shows that Wolfe vectors can serve easily as\nmatrix and tensor representations. Of course this may not be the most efficient representation,\nbut Wolfe internally converts vectors to optimized representations anyway. ",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 12,
    "compiler" : "wolfe",
    "input" : {
      "code" : "val x = Vector(0 -> 1.0, 1 -> 2.0)\nx outer x",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 13,
    "compiler" : "heading3",
    "input" : {
      "code" : "Operations",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 14,
    "compiler" : "markdown",
    "input" : {
      "code" : "Wolfe vectors support the common vector operations, most importantly summation and inner products.",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 15,
    "compiler" : "wolfe",
    "input" : {
      "code" : "(oneHot('A, 2.0) + oneHot('B, 2.0)) dot (oneHot('A,3.0) + oneHot('B,4.0))",
      "outputFormat" : "string",
      "extraFields" : null
    }
  } ]
}
