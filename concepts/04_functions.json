{
  "name" : "Scalar Functions",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "code" : "As illustrated before, scalar functions are the main building blocks of Wolfe. As a functional\nprogramming language, Scala is well suited to allow defining and composing such blocks. \n\nScalar functions in Scala are simply functions of type `T => Double`, and any such function\ncan be used within Wolfe to define a model. However, generally there are functions for which\nWolfe can perform optimizations, and functions for which it can't. Moreover, \nfor mathematical operators to be efficient, the more factorized a function is, the better.\nBelow we outline certain classes of functions Wolfe can optimize and factorize.",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 1,
    "compiler" : "heading3",
    "input" : {
      "code" : "Atomic Functions",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "code" : "Wolfe tries to break down models into a tree of factors, and at the leaves of this tree\nyou find functions that cannot be factorized further. We will refer to these leaves as\n*atomic*. Most functions are atomic, unless they contain factorizable structure such as\nsums. In particular, you can use any user-defined functions as atomic building blocks of your model.\n\nOne very useful atomic function is the [Iverson Bracket](http://en.wikipedia.org/wiki/Iverson_bracket)\nthat maps boolean expressions into {0,1}. This function is useful for \nbinary features as well logic-based formalisms such as Markov Logic. That's why\nWolfe provides the Iverson Bracket also as a built-in function.\n",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 3,
    "compiler" : "wolfe",
    "input" : {
      "code" : "def I(pred:Boolean) = if (pred) 1.0 else 0.0\nI(true)",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 4,
    "compiler" : "heading3",
    "input" : {
      "code" : "Propositional Sums",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 5,
    "compiler" : "markdown",
    "input" : {
      "code" : "Wolfe breaks up expressions that are are sums of other expressions and utilizes this \ndecomposition when applying mathematical operators. To create sums simply use the Scala\nplus operator.",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 6,
    "compiler" : "wolfe",
    "input" : {
      "code" : "case class PropositionalWorld(smokesAnna:Boolean, smokesBob:Boolean)\ndef s(w:PropositionalWorld) = I(w.smokesAnna) + I(w.smokesBob)\ns(PropositionalWorld(true,false))",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 7,
    "compiler" : "heading3",
    "input" : {
      "code" : "Quantified Sums",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 8,
    "compiler" : "markdown",
    "input" : {
      "code" : "Often sums have a repetitive structure and can be formulated in quantifed form\n<div>$$\nf(x) = \\sum\\_i f\\_i(x)\n$$</div>\nIn Wolfe this can achieved using the `sum` operator. ",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 9,
    "compiler" : "wolfe",
    "input" : {
      "code" : "case class World(smokes:Pred[Symbol])\nval persons = List('Anna,'Bob,'Peter)\ndef f(w:World) = sum(persons) { p => I(w.smokes(p))}\nval world = World(Map('Anna -> true, 'Bob -> true, 'Peter -> false))\nf(world)",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 10,
    "compiler" : "heading3",
    "input" : {
      "code" : "Dot Products",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 11,
    "compiler" : "markdown",
    "input" : {
      "code" : "Super useful...",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 12,
    "compiler" : "wolfe",
    "input" : {
      "code" : "def feats1(pred:Boolean) = oneHot('pred, I(pred))\nfeats1(true) dot oneHot('pred, 3.0)",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 13,
    "compiler" : "markdown",
    "input" : {
      "code" : "Wolfe supports factorization of vector expressions as well. So writing the code\nbelow is equivalent to writing the sum of the dot products.",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 14,
    "compiler" : "wolfe",
    "input" : {
      "code" : "def feats2(s:PropositionalWorld) = \n  oneHot('smokes, I(s.smokesAnna)) + \n  oneHot('smokes, I(s.smokesBob))\nval world2 = PropositionalWorld(true,true)\nfeats2(world2) dot oneHot('smokes,1.0)",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 15,
    "compiler" : "markdown",
    "input" : {
      "code" : "Quantified sums",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 16,
    "compiler" : "wolfe",
    "input" : {
      "code" : "def feats3(w:World) = sum(persons) { p => oneHot('smokes, I(w.smokes(p))) }\nval world3 = World(Map('Anna -> true, 'Bob -> true, 'Peter -> false))\nfeats3(world3) dot oneHot('smokes,1.0)",
      "outputFormat" : "string",
      "extraFields" : null
    }
  } ]
}
