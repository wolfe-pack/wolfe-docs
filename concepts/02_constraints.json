{
  "name" : "Constraints",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "code" : "In Machine Learning we usually observe parts of the world, or know certain \nconstraints or invariants, and then infer information about what is still hidden.\nFor example, to find the most likely, or highest scoring, possible world we\nwould solve a problem of the form\n$$\n\\DeclareMathOperator{\\argmax}{arg max}\n\\argmax_{s \\in \\mathcal{S}:c(s)} f(s)  \n$$\nwhere \\\\(c(\\cdot)\\\\) is a boolean predicate or filter on possible worlds \\\\(s\\\\).\n\nIn Wolfe observations and constraints are implemented as Scala functions from\npossible worlds to booleans. You can use any function you like\nbut optimized behaviour can only be guaranteed for the ones below.\n\n\n\n",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 1,
    "compiler" : "heading3",
    "input" : {
      "code" : "Equalities",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "code" : "The simplest type of constraints are equalities on sub-structures within a world.\n\n\n\n",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 3,
    "compiler" : "wolfe",
    "input" : {
      "code" : "case class Token(word:String,label:String)\nval words = List(\"eat\",\"house\")\nval labels = List(\"Verb\",\"Noun\")\nval tokens = all(Token) {words x labels}\ndef constraint1(t:Token) = t.word == \"eat\"\ntokens filter constraint1",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 4,
    "compiler" : "heading3",
    "input" : {
      "code" : "Boolean Attributes",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 5,
    "compiler" : "markdown",
    "input" : {
      "code" : "If substructures, such as predicates, evaluate to boolean values \nyou can use these directly as constraints. \nThis can make constraints in Wolfe look similar to constraints in Markov Logic \nand other related formalisms.\n",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 6,
    "compiler" : "wolfe",
    "input" : {
      "code" : "case class Person(name:String)\ncase class World(smokes:Pred[Person])\nval persons = List(Person(\"Anna\"),Person(\"Bob\"))\nval worlds = all(World) { preds(persons) }\ndef constraint2(w:World) = w.smokes(Person(\"Anna\"))\nworlds filter constraint2",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 7,
    "compiler" : "heading3",
    "input" : {
      "code" : "Conjunctions",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 8,
    "compiler" : "markdown",
    "input" : {
      "code" : "You can conjoin constraints using the scala `&&` operator.\n\n",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 9,
    "compiler" : "wolfe",
    "input" : {
      "code" : "def constraint3(t:Token) = t.word == \"eat\" && t.label == \"Verb\"\ntokens filter constraint3",
      "outputFormat" : "string",
      "extraFields" : null
    }
  }, {
    "id" : 10,
    "compiler" : "heading3",
    "input" : {
      "code" : "Observations",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 11,
    "compiler" : "markdown",
    "input" : {
      "code" : "Often we are given a world in which most sub-structures are observed, and we have to make \ninferences about only a small subset of other sub-structures. For example, \nin classification you are given a large number of features, and the only hidden \nvariable is the classification label. \n\nIn Wolfe this use case is supported by requiring equality to an *observed*\nworld, but only after the hidden attributes have been retracted (see line 8 below).\nNotice that there is nothing special about the expression `hidden`,\nit's just a arbitrary but fixed value of the correct type. Try replacing\nthis value with a string of your choice, and the result will be the same.\n\n\n",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 12,
    "compiler" : "wolfe",
    "input" : {
      "code" : "case class Sentence(tokens:Seq[Token])\nval sentences = all(Sentence) { seqs( all(Token) {words x labels}, 3)}\nval instance = Sentence(Seq(Token(\"eat\",\"Verb\"),Token(\"house\",\"Noun\"))) \ndef observed(s:Sentence) = \n  s.copy(tokens = s.tokens.map(_.copy(label = hidden)))\ndef constraint4(s:Sentence) = observed(s) == observed(instance)\nsentences filter constraint4",
      "outputFormat" : "string",
      "extraFields" : null
    }
  } ]
}
