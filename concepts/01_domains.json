{
  "name" : "Domains",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Machine learning models are often represented as scalar functions \n$$f:\\mathcal{S}\\mapsto\\mathbb{R}$$ \nfrom a _domain_ (or a _sample space_ or _search space_) \\\\(\\mathcal{S}\\\\) to reals \\\\(\\mathbb{R}\\\\) that \nmeasure the score or probability of an element in the search space, or an empirical loss of an element in the space of model parameters. For example, we could talk about (word,part-of-speech-tag) pair, or something more structured \nsuch as a sequence of observations and labels, or a set of parameter vectors in a matrix factorization model. \n\nIn Wolfe you develop such scalar functions, and the\nfirst step is to define the domains \\\\(\\mathcal{S}\\\\) of such functions. To this end Wolfe provides a [Domain](todo) class. Note that in the case of discrete domains this class can be seen as a glorified scala collection, and there exist mappings from collections to domains, and vice versa.\n",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 1,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Atomic Domains",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Say we want to classify words as nouns or verbs. At the core of this task is an _atomic_ domain\nof labels, in this case \"Noun\" and \"Verb.\" In Wolfe you can use simple scala iterables to define\nsuch atomic collections, such as a [List](http://www.scala-lang.org/api/2.10.3/index.html#scala.collection.immutable.List). Provided that you have imported `ml.wolfe.term.TermImplicits._`, the `toDom` method on any iterable creates a discrete domain with elements of the given iterable.  ",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 3,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "List(\"Verb\",\"Noun\").toDom",
      "extraFields" : {
        "aggregatedCells" : "[]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 4,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "As mentioned above, (discrete) domains can be mapped to iterables. This can be achieved by calling `toIterable` on the domain object. Notice that in practice mapping back to iterables is mostly used for inspecting and debugging domains. ",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 5,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "List(\"Verb\",\"Noun\").toDom.toIterable",
      "extraFields" : {
        "aggregatedCells" : "[\"List(\\\"Verb\\\",\\\"Noun\\\").toDom\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 6,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Of course scala [Range](http://www.scala-lang.org/api/2.10.3/index.html#scala.collection.immutable.Range)\nobjects can serve as collections of possible worlds as well.",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 7,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "Ints(0 until 100).toIterable.take(4)",
      "extraFields" : {
        "aggregatedCells" : "[\"List(\\\"Verb\\\",\\\"Noun\\\").toDom\",\"List(\\\"Verb\\\",\\\"Noun\\\").toDom.toIterable\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 8,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Multivariate Domains",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 9,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "In practice elements in search spaces have several interacting components. For example, \nin the case of part-of-speech classification a token has a word and a part-of-speech,\nand the former helps to determine the latter. In Wolfe such worlds can be \ndescribed using Scala [case classes](http://www.codecommit.com/blog/scala/case-classes-are-cool). \n\nTo compactly describe a (factorized) domain of case class objects, Wolfe provides the `@domain` macro. When used as annotation for a case class, this macro generates a `Values` constructor for the case class that can be used to compose a domain of objects of this case class based on domains for the arguments of the case class. ",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 10,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "@ml.wolfe.term.domain case class Person(age:Int, nam:String)\nPerson.Values(Ints(30 until 32),List(\"Anna\",\"Bob\").toDom).toIterable",
      "extraFields" : {
        "aggregatedCells" : "[\"List(\\\"Verb\\\",\\\"Noun\\\").toDom\",\"List(\\\"Verb\\\",\\\"Noun\\\").toDom.toIterable\",\"Ints(0 until 100).toIterable.take(4)\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 11,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "When case classes have many fields, and evolve over time, maintaining the correct order of the \ncartesian product can become tedious. Assuming each field has \na different scala type, we can avoid this problem by declaring the arguments of the\ncartesian product using scala implicits. Below you see the above example adapted\nto use the [Symbol](http://www.scala-lang.org/api/2.10.3/index.html#scala.Symbol) \nclass as label in order to make field types unique. \n\n\n",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 12,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Sequences",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 13,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Many real world problems, such as tagging in NLP, or gene sequencing,\nconcern sequences of objects. In Wolfe `seqs(worlds,maxLength)` takes a collection\nof possible worlds `worlds` and generates all possible sequences over these worlds\nup to a maximum length `maxLength`.\n\n",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 14,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "The base collection of possible worlds can be any scala iterable. In particular, it can be\npossible worlds constructed using other operators.",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 15,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Maps",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 16,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Wolfe supports the Scala [Map](http://www.scala-lang.org/api/2.10.4/index.html#scala.collection.immutable.Map) class to \nrepresent mappings from a domain to a range. Such mappings can be very useful, for example \nto represent relations and graphs, as shown in the example below. To generate \nall possible maps from a domain `dom` to a range `range` use the `maps(dom,range)`\nfunction.\n\n",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 17,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Predicates",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 18,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "In Wolfe predicates are special cases of maps from some domain to {true,false}. \nAs they are frequently useful, Wolfe provide syntactic sugar to make their use easier.\n\n",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 19,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Infinite Collections",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 20,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Often we need infinite collections of possible worlds. For example,\na possible world may have real-valued attributes, and hence there are infinitely\nmany possibilities unless with discretize the attribute. Another example\nare string attributes such as the word of a token. Given that people constantly produce \nnew words, and typos, such string attributes can be considered infinite as well.\n\nIn Wolfe infinite collections can be constructed with the `infty[T]` \nmethod that returns an infinite collection of type `T`. Note that such\ncollections really only serve as placeholders, and one cannot iterate\nover the infinite collection. Because of this, Wolfe currently \n__requires infinite attributes to be observed__.\n\n",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 21,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Built-in Collections",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 22,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Wolfe comes with a set of built in collections of possible worlds that can be used to \nconstruct more complex ones.",
      "extraFields" : { },
      "outputFormat" : null
    }
  } ],
  "config" : { }
}
