{
  "name" : "Terms",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Our goal is to compose mathematical objectives of the form \n\\\\(f:\\mathcal{S}\\mapsto\\mathbb{R}\\\\). Being able to define the domains \\\\(\\mathcal{S}\\\\) we can now go on to construct \\\\(f\\\\). In Wolfe this is done by constructing the _term_ \\\\(f(s)\\\\) that represents the function applied to an element \\\\(s \\in \\mathcal{S}\\\\). \n\nTerms in wolfe are represented through the `Term` trait. Each `Term` object has a domain, and _evaluates_ to a value in this domain based on an assignment to the free variables in the term. The way a term evaluates to a value defines the term's semantics. You can test what a term `t` evaluates to by calling `t(freeVar1 := value1, freeVar2 := value2, ...)`. If a term `t` has no free variables, simply call `t()`. \n\nTerms are constructed using the Wolfe Term DSL. Here basic term primitives, such as variables and  constants can be composed into complex mathematical objectives using constructs such as sequence or map accessors, plus and sum operators and even argmax expressions. The Wolfe Term DSL attempts to be as close as possible to Scala syntax, and hence often Wolfe Terms will look like standard scala expressions. However, it is important to point out that they are symbolic descriptions that define some computation, and they can be analyzed at runtime to derive gradients, maximization algorithms etc.  \n\nIn the following we will present a range of primitive and more complex terms.\n\n### Variables\n\nOne of the the simplest types of terms are _variables_. The value of a variable is the value assigned to this variable in a given binding. To construct a variable, you can use the `Var` constructor defined on domains. ",
      "extraFields" : {
        "aggregatedCells" : "[]"
      },
      "outputFormat" : "<p>Our goal is to compose mathematical objectives of the form <span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><span class=\"MathJax\" id=\"MathJax-Element-1-Frame\"><nobr><span class=\"math\" id=\"MathJax-Span-1\" role=\"math\" style=\"width: 5.182em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.289em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(2.146em 1000.003em 3.336em -999.997em); top: -2.973em; left: 0.003em;\"><span class=\"mrow\" id=\"MathJax-Span-2\"><span class=\"mi\" id=\"MathJax-Span-3\" style=\"font-family: STIXGeneral-Italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.122em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-4\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.301em;\">:</span><span class=\"texatom\" id=\"MathJax-Span-5\" style=\"padding-left: 0.301em;\"><span class=\"mrow\" id=\"MathJax-Span-6\"><span class=\"mi\" id=\"MathJax-Span-7\" style=\"font-family: STIXNonUnicode-Italic;\"><span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.063em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-8\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.301em;\">↦</span><span class=\"texatom\" id=\"MathJax-Span-9\" style=\"padding-left: 0.301em;\"><span class=\"mrow\" id=\"MathJax-Span-10\"><span class=\"mi\" id=\"MathJax-Span-11\" style=\"font-family: STIXGeneral-Regular;\">ℝ</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.979em;\"></span></span></span><span style=\"border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.218em; vertical-align: -0.282em;\"></span></span></nobr></span><script type=\"math/tex\" id=\"MathJax-Element-1\">f:\\mathcal{S}\\mapsto\\mathbb{R}</script>. Being able to define the domains <span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><span class=\"MathJax\" id=\"MathJax-Element-2-Frame\"><nobr><span class=\"math\" id=\"MathJax-Span-12\" role=\"math\" style=\"width: 0.896em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.717em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(2.146em 1000.003em 3.158em -999.997em); top: -2.973em; left: 0.003em;\"><span class=\"mrow\" id=\"MathJax-Span-13\"><span class=\"texatom\" id=\"MathJax-Span-14\"><span class=\"mrow\" id=\"MathJax-Span-15\"><span class=\"mi\" id=\"MathJax-Span-16\" style=\"font-family: STIXNonUnicode-Italic;\"><span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.063em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.979em;\"></span></span></span><span style=\"border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.932em; vertical-align: -0.068em;\"></span></span></nobr></span><script type=\"math/tex\" id=\"MathJax-Element-2\">\\mathcal{S}</script> we can now go on to construct <span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><span class=\"MathJax\" id=\"MathJax-Element-3-Frame\"><nobr><span class=\"math\" id=\"MathJax-Span-17\" role=\"math\" style=\"width: 0.539em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.42em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.729em 1000.003em 2.92em -999.997em); top: -2.557em; left: 0.003em;\"><span class=\"mrow\" id=\"MathJax-Span-18\"><span class=\"mi\" id=\"MathJax-Span-19\" style=\"font-family: STIXGeneral-Italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.122em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.562em;\"></span></span></span><span style=\"border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.218em; vertical-align: -0.282em;\"></span></span></nobr></span><script type=\"math/tex\" id=\"MathJax-Element-3\">f</script>. In Wolfe this is done by constructing the <em>term</em> <span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><span class=\"MathJax\" id=\"MathJax-Element-4-Frame\"><nobr><span class=\"math\" id=\"MathJax-Span-20\" role=\"math\" style=\"width: 1.789em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.491em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.729em 1000.003em 2.92em -999.997em); top: -2.557em; left: 0.003em;\"><span class=\"mrow\" id=\"MathJax-Span-21\"><span class=\"mi\" id=\"MathJax-Span-22\" style=\"font-family: STIXGeneral-Italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.122em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-23\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-24\" style=\"font-family: STIXGeneral-Italic;\">s</span><span class=\"mo\" id=\"MathJax-Span-25\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.562em;\"></span></span></span><span style=\"border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.218em; vertical-align: -0.282em;\"></span></span></nobr></span><script type=\"math/tex\" id=\"MathJax-Element-4\">f(s)</script> that represents the function applied to an element <span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><span class=\"MathJax\" id=\"MathJax-Element-5-Frame\"><nobr><span class=\"math\" id=\"MathJax-Span-26\" role=\"math\" style=\"width: 2.86em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.384em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(2.146em 1000.003em 3.158em -999.997em); top: -2.973em; left: 0.003em;\"><span class=\"mrow\" id=\"MathJax-Span-27\"><span class=\"mi\" id=\"MathJax-Span-28\" style=\"font-family: STIXGeneral-Italic;\">s</span><span class=\"mo\" id=\"MathJax-Span-29\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.301em;\">∈</span><span class=\"texatom\" id=\"MathJax-Span-30\" style=\"padding-left: 0.301em;\"><span class=\"mrow\" id=\"MathJax-Span-31\"><span class=\"mi\" id=\"MathJax-Span-32\" style=\"font-family: STIXNonUnicode-Italic;\"><span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.063em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.979em;\"></span></span></span><span style=\"border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.004em; vertical-align: -0.068em;\"></span></span></nobr></span><script type=\"math/tex\" id=\"MathJax-Element-5\">s \\in \\mathcal{S}</script>. </p><p>Terms in wolfe are represented through the <code>Term</code> trait. Each <code>Term</code> object has a domain, and <em>evaluates</em> to a value in this domain based on an assignment to the free variables in the term. The way a term evaluates to a value defines the term's semantics. You can test what a term <code>t</code> evaluates to by calling <code>t(freeVar1 := value1, freeVar2 := value2, ...)</code>. If a term <code>t</code> has no free variables, simply call <code>t()</code>. </p><p>Terms are constructed using the Wolfe Term DSL. Here basic term primitives, such as variables and constants can be composed into complex mathematical objectives using constructs such as sequence or map accessors, plus and sum operators and even argmax expressions. The Wolfe Term DSL attempts to be as close as possible to Scala syntax, and hence often Wolfe Terms will look like standard scala expressions. However, it is important to point out that they are symbolic descriptions that define some computation, and they can be analyzed at runtime to derive gradients, maximization algorithms etc. </p><p>In the following we will present a range of primitive and more complex terms.</p><h3>Variables</h3><p>One of the the simplest types of terms are <em>variables</em>. The value of a variable is the value assigned to this variable in a given binding. To construct a variable, you can use the <code>Var</code> constructor defined on domains. </p>"
    }
  }, {
    "id" : 1,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val b = Bools.Var\nb.eval(b := true)",
      "extraFields" : {
        "aggregatedCells" : "[]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">true</span></div>"
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "It's worthwhile noting that variables can also be created for complex structured domains.",
      "extraFields" : { },
      "outputFormat" : "<p>It's worthwhile noting that variables can also be created for complex structured domains.</p>"
    }
  }, {
    "id" : 3,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val s = Seqs(Bools,2).Var\ns.eval(s := IndexedSeq(false,true))",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div class=\"asIterable Vector\"><span class=\"typeName\">Vector</span>\n<ol start=\"0\" class=\"fields\">\n  <li class=\"fieldValue\"><span class=\"asString String\">false</span></li>\n  <li class=\"fieldValue\"><span class=\"asString String\">true</span></li>\n</ol>\n</div></div>"
    }
  }, {
    "id" : 4,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Constants\n\nConstants are terms that always evaluate to the same value. To create a constant of a given domain you can call the domain's `Const` method.",
      "extraFields" : { },
      "outputFormat" : "<h3>Constants</h3><p>Constants are terms that always evaluate to the same value. To create a constant of a given domain you can call the domain's <code>Const</code> method.</p>"
    }
  }, {
    "id" : 5,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "Bools.Const(true)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div id=\"term5a8adbe4-c333-4152-8c0b-01aa2f7646b1\" class=\"term\">\n<svg width=\"960\" height=\"140\"><g transform=\"translate(120,40)\"><g class=\"node\" transform=\"translate(40,0)\"><circle r=\"10\"></circle><text y=\"18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">true</text></g></g></svg>\n</div>\n<script>\n\nvar treeData = [\n\n{\n  \"name\": \"true\",\n  \"parent\": \"null\",\n  \"children\": []\n}\n\n];\n\nvar depth = 1 + 1\n\n// ************** Generate the tree diagram\t *****************\nvar margin = {top: 40, right: 120, bottom: 20, left: 120},\n\twidth = 960 - margin.right - margin.left,\n\theight = depth * 70 - margin.top - margin.bottom;\n\nvar i = 0;\n\nvar tree = d3.layout.tree()\n\t.size([height, width]);\n\nvar diagonal = d3.svg.diagonal()\n\t.projection(function(d) { return [d.x, d.y]; });\n\nvar svg = d3.select(\"#term5a8adbe4-c333-4152-8c0b-01aa2f7646b1 svg\")\n\t.attr(\"width\", width + margin.right + margin.left)\n\t.attr(\"height\", height + margin.top + margin.bottom)\n  .append(\"g\")\n\t.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\nroot = treeData[0];\n\nupdate(root);\n\nfunction update(source) {\n\n  // Compute the new tree layout.\n  var nodes = tree.nodes(source).reverse(),\n\t links = tree.links(nodes);\n\n  // Normalize for fixed-depth.\n  nodes.forEach(function(d) { d.y = d.depth * 50; });\n\n  // Declare the nodes…\n  var node = svg.selectAll(\"g.node\")\n\t  .data(nodes, function(d) { return d.id || (d.id = ++i); });\n\n  // Enter the nodes.\n  var nodeEnter = node.enter().append(\"g\")\n\t  .attr(\"class\", \"node\")\n\t  .attr(\"transform\", function(d) {\n\t\t  return \"translate(\" + d.x + \",\" + d.y + \")\"; });\n\n  nodeEnter.append(\"circle\")\n\t  .attr(\"r\", 10);\n\n  nodeEnter.append(\"text\")\n\t  .attr(\"y\", function(d) {\n\t\t  return d.children || d._children ? -18 : 18; })\n\t  .attr(\"dy\", \".35em\")\n\t  .attr(\"text-anchor\", \"middle\")\n\t  .text(function(d) { return d.name; })\n\t  .style(\"fill-opacity\", 1);\n\n  // Declare the links…\n  var link = svg.selectAll(\"path.link\")\n\t  .data(links, function(d) { return d.target.id; });\n\n  // Enter the links.\n  link.enter().insert(\"path\", \"g\")\n\t  .attr(\"class\", \"link\")\n\t  .attr(\"d\", diagonal);\n\n}\n\n</script></div>"
    }
  }, {
    "id" : 6,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "To evaluate a constant no assignment to free variables are necessary.",
      "extraFields" : { },
      "outputFormat" : "<p>To evaluate a constant no assignment to free variables are necessary.</p>"
    }
  }, {
    "id" : 7,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "Bools.Const(true).eval()",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">true</span></div>"
    }
  }, {
    "id" : 8,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "You can avoid an explicit mention of the domain by introducing the domain as `implicit` value. Now every time you call `toConst` on a value of this domain, the matching `Const` constructor is implicitly called.",
      "extraFields" : { },
      "outputFormat" : "<p>You can avoid an explicit mention of the domain by introducing the domain as <code>implicit</code> value. Now every time you call <code>toConst</code> on a value of this domain, the matching <code>Const</code> constructor is implicitly called.</p>"
    }
  }, {
    "id" : 9,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "implicit val Instances = Seqs(Bools,2)\nval t = Seq(false,true).toConst\nt.eval()",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div class=\"asIterable Vector\"><span class=\"typeName\">Vector</span>\n<ol start=\"0\" class=\"fields\">\n  <li class=\"fieldValue\"><span class=\"asString String\">false</span></li>\n  <li class=\"fieldValue\"><span class=\"asString String\">true</span></li>\n</ol>\n</div></div>"
    }
  }, {
    "id" : 10,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "For primitive types such as `Double`, `Boolean` and `Int` Wolfe provides direct conversions from values to constants.",
      "extraFields" : { },
      "outputFormat" : "<p>For primitive types such as <code>Double</code>, <code>Boolean</code> and <code>Int</code> Wolfe provides direct conversions from values to constants.</p>"
    }
  }, {
    "id" : 11,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val d:DoubleTerm = 1.0\nd.eval()",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">1.0</span></div>"
    }
  }, {
    "id" : 12,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Boolean Operators\n\nBoolean variables and constants can be composed using boolean functions. Wolfe provides the standard Scala operations on Booleans, as well as implication `-->` and equivalence `<->` to build models of probabilistic logic. ",
      "extraFields" : { },
      "outputFormat" : "<h3>Boolean Operators</h3><p>Boolean variables and constants can be composed using boolean functions. Wolfe provides the standard Scala operations on Booleans, as well as implication <code>--&gt;</code> and equivalence <code>&lt;-&gt;</code> to build models of probabilistic logic. </p>"
    }
  }, {
    "id" : 13,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val x = Bools.Var\nval y = Bools.Var\nval or = (x || y)\nor",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div id=\"termda110046-0443-4082-a3fe-b8237e3b8637\" class=\"term\">\n<svg width=\"960\" height=\"210\"><g transform=\"translate(120,40)\"><path class=\"link\" d=\"M75,0C75,25 37.5,25 37.5,50\"></path><path class=\"link\" d=\"M75,0C75,25 112.5,25 112.5,50\"></path><g class=\"node\" transform=\"translate(112.5,50)\"><circle r=\"10\"></circle><text y=\"18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">y </text></g><g class=\"node\" transform=\"translate(37.5,50)\"><circle r=\"10\"></circle><text y=\"18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">x </text></g><g class=\"node\" transform=\"translate(75,0)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">Or</text></g></g></svg>\n</div>\n<script>\n\nvar treeData = [\n\n{\n  \"name\": \"Or\",\n  \"parent\": \"null\",\n  \"children\": [\n{\n  \"name\": \"x \",\n  \"parent\": \"Or\",\n  \"children\": []\n}\n             ,\n\n{\n  \"name\": \"y \",\n  \"parent\": \"Or\",\n  \"children\": []\n}\n             ]\n}\n\n];\n\nvar depth = 2 + 1\n\n// ************** Generate the tree diagram\t *****************\nvar margin = {top: 40, right: 120, bottom: 20, left: 120},\n\twidth = 960 - margin.right - margin.left,\n\theight = depth * 70 - margin.top - margin.bottom;\n\nvar i = 0;\n\nvar tree = d3.layout.tree()\n\t.size([height, width]);\n\nvar diagonal = d3.svg.diagonal()\n\t.projection(function(d) { return [d.x, d.y]; });\n\nvar svg = d3.select(\"#termda110046-0443-4082-a3fe-b8237e3b8637 svg\")\n\t.attr(\"width\", width + margin.right + margin.left)\n\t.attr(\"height\", height + margin.top + margin.bottom)\n  .append(\"g\")\n\t.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\nroot = treeData[0];\n\nupdate(root);\n\nfunction update(source) {\n\n  // Compute the new tree layout.\n  var nodes = tree.nodes(source).reverse(),\n\t links = tree.links(nodes);\n\n  // Normalize for fixed-depth.\n  nodes.forEach(function(d) { d.y = d.depth * 50; });\n\n  // Declare the nodes…\n  var node = svg.selectAll(\"g.node\")\n\t  .data(nodes, function(d) { return d.id || (d.id = ++i); });\n\n  // Enter the nodes.\n  var nodeEnter = node.enter().append(\"g\")\n\t  .attr(\"class\", \"node\")\n\t  .attr(\"transform\", function(d) {\n\t\t  return \"translate(\" + d.x + \",\" + d.y + \")\"; });\n\n  nodeEnter.append(\"circle\")\n\t  .attr(\"r\", 10);\n\n  nodeEnter.append(\"text\")\n\t  .attr(\"y\", function(d) {\n\t\t  return d.children || d._children ? -18 : 18; })\n\t  .attr(\"dy\", \".35em\")\n\t  .attr(\"text-anchor\", \"middle\")\n\t  .text(function(d) { return d.name; })\n\t  .style(\"fill-opacity\", 1);\n\n  // Declare the links…\n  var link = svg.selectAll(\"path.link\")\n\t  .data(links, function(d) { return d.target.id; });\n\n  // Enter the links.\n  link.enter().insert(\"path\", \"g\")\n\t  .attr(\"class\", \"link\")\n\t  .attr(\"d\", diagonal);\n\n}\n\n</script></div>"
    }
  }, {
    "id" : 14,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "or.eval(x := false, y := true)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">true</span></div>"
    }
  }, {
    "id" : 15,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "When creating objectives, in particular over discrete spaces, one often needs to convert boolean experssion to double expressions. For this Wolfe provides the [Iverson Bracket](http://en.wikipedia.org/wiki/Iverson_bracket) operator `I(x)`. It evaluates to `1.0` if the inner term `x` evaluates to `true` and `0.0` otherwise.",
      "extraFields" : { },
      "outputFormat" : "<p>When creating objectives, in particular over discrete spaces, one often needs to convert boolean experssion to double expressions. For this Wolfe provides the <a href=\"http://en.wikipedia.org/wiki/Iverson_bracket\">Iverson Bracket</a> operator <code>I(x)</code>. It evaluates to <code>1.0</code> if the inner term <code>x</code> evaluates to <code>true</code> and <code>0.0</code> otherwise.</p>"
    }
  }, {
    "id" : 16,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "I(or).eval(x := false, y := true)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor\",\"or.eval(x := false, y := true)\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">1.0</span></div>"
    }
  }, {
    "id" : 17,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Numeric Operators\n\nThe final goal of modelling in Wolfe is to build functions from search or sample spaces to real values. Naturally Wolfe hence provides a range of functions to compose complex real terms from simpler ones, such as addition, multiplication and the `log` operator.   ",
      "extraFields" : { },
      "outputFormat" : "<h3>Numeric Operators</h3><p>The final goal of modelling in Wolfe is to build functions from search or sample spaces to real values. Naturally Wolfe hence provides a range of functions to compose complex real terms from simpler ones, such as addition, multiplication and the <code>log</code> operator. </p>"
    }
  }, {
    "id" : 18,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val b = Bools.Var\nval x = Doubles.Var\nlog(x + I(b) * 2.0).eval(b := false, x := 2.0)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor\",\"or.eval(x := false, y := true)\",\"I(or).eval(x := false, y := true)\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">0.6931471805599453</span></div>"
    }
  }, {
    "id" : 19,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Likewise, Wolfe provides the common operations on integers one would expect.  ",
      "extraFields" : { },
      "outputFormat" : "<p>Likewise, Wolfe provides the common operations on integers one would expect. </p>"
    }
  }, {
    "id" : 20,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val i = Ints.Var\n(i * 2 - 1).eval(i := 5)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor\",\"or.eval(x := false, y := true)\",\"I(or).eval(x := false, y := true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0).eval(b := false, x := 2.0)\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">9</span></div>"
    }
  }, {
    "id" : 21,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Vector Operators\n\nParameter vectors, layers of neural networks and word-embeddings are examples of vector representations. To facilitate working with such representations, Wolfe provides many standard operators on vectors, e.g. dot products, matrix-vector multiplications or simply component-wise \napplications of real-valued functions.",
      "extraFields" : { },
      "outputFormat" : "<h3>Vector Operators</h3><p>Parameter vectors, layers of neural networks and word-embeddings are examples of vector representations. To facilitate working with such representations, Wolfe provides many standard operators on vectors, e.g. dot products, matrix-vector multiplications or simply component-wise applications of real-valued functions.</p>"
    }
  }, {
    "id" : 22,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val x = Vectors(2).Var\n(x dot x).eval(x := vector(1,2))",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor\",\"or.eval(x := false, y := true)\",\"I(or).eval(x := false, y := true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0).eval(b := false, x := 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1).eval(i := 5)\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">5.0</span></div>"
    }
  }, {
    "id" : 23,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Sequence Terms\n\nWe have earlier introduced sequence domains. Terms of sequences, such as sequence variables or constants, provide an element accessor operator `s(i)` that returns a term representing the `i`th element of the sequence represented by `s`.   ",
      "extraFields" : { },
      "outputFormat" : "<h3>Sequence Terms</h3><p>We have earlier introduced sequence domains. Terms of sequences, such as sequence variables or constants, provide an element accessor operator <code>s(i)</code> that returns a term representing the <code>i</code>th element of the sequence represented by <code>s</code>. </p>"
    }
  }, {
    "id" : 24,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : " val s = Seqs(Bools,0,2).Var\n val i = Ints(0 until 2).Var\n s(i).eval(s := IndexedSeq(false,true),i := 1)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor\",\"or.eval(x := false, y := true)\",\"I(or).eval(x := false, y := true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0).eval(b := false, x := 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1).eval(i := 5)\",\"val x = Vectors(2).Var\\n(x dot x).eval(x := vector(1,2))\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">true</span></div>"
    }
  }, {
    "id" : 25,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Via the `length` method you can also create a term representing the length of a sequence. ",
      "extraFields" : { },
      "outputFormat" : "<p>Via the <code>length</code> method you can also create a term representing the length of a sequence. </p>"
    }
  }, {
    "id" : 26,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "s.length.eval(s := IndexedSeq(false))",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor\",\"or.eval(x := false, y := true)\",\"I(or).eval(x := false, y := true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0).eval(b := false, x := 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1).eval(i := 5)\",\"val x = Vectors(2).Var\\n(x dot x).eval(x := vector(1,2))\",\" val s = Seqs(Bools,0,2).Var\\n val i = Ints(0 until 2).Var\\n s(i).eval(s := IndexedSeq(false,true),i := 1)\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">1</span></div>"
    }
  }, {
    "id" : 27,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Map Terms\n\nMap terms support access to the map's element via a key. ",
      "extraFields" : { },
      "outputFormat" : "<h3>Map Terms</h3><p>Map terms support access to the map's element via a key. </p>"
    }
  }, {
    "id" : 28,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val m = Maps(Bools,Doubles).Var\nval k = Bools.Var\nm(k).eval(m := Map(true -> 1.0, false -> 2.0),k := false)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor\",\"or.eval(x := false, y := true)\",\"I(or).eval(x := false, y := true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0).eval(b := false, x := 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1).eval(i := 5)\",\"val x = Vectors(2).Var\\n(x dot x).eval(x := vector(1,2))\",\" val s = Seqs(Bools,0,2).Var\\n val i = Ints(0 until 2).Var\\n s(i).eval(s := IndexedSeq(false,true),i := 1)\",\"s.length.eval(s := IndexedSeq(false))\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">2.0</span></div>"
    }
  }, {
    "id" : 29,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Quantified Sums\n\nSequence and map domains allow users to compactly define structured search spaces. Most of the time objectives on such spaces have a very repetitive (additive) structure, and can hence be defined compactly as well. For example, a training objective of instances \\\\(i\\\\) can be defined through \\\\(\\sum_i l(i)\\\\) where \\\\(l(i)\\\\) is some local loss. In Wolfe such terms can be formulated using the `sum(range)(body)` operator that represents the sum \n$$\\sum_{i \\in \\mathit{range}} \\mathit{body}(i)$$\nwhere `body` is a function from the element domain of `range` to the domain `Doubles` of reals. \n\nA simple example of an applied `sum` operator can be used to count the number of `true` elements in a sequence of Booleans.  \n",
      "extraFields" : { },
      "outputFormat" : "<h3>Quantified Sums</h3><p>Sequence and map domains allow users to compactly define structured search spaces. Most of the time objectives on such spaces have a very repetitive (additive) structure, and can hence be defined compactly as well. For example, a training objective of instances <span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><span class=\"MathJax\" id=\"MathJax-Element-6-Frame\"><nobr><span class=\"math\" id=\"MathJax-Span-33\" role=\"math\" style=\"width: 0.36em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.301em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.729em 1000.003em 2.741em -999.997em); top: -2.557em; left: 0.003em;\"><span class=\"mrow\" id=\"MathJax-Span-34\"><span class=\"mi\" id=\"MathJax-Span-35\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.562em;\"></span></span></span><span style=\"border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.932em; vertical-align: -0.068em;\"></span></span></nobr></span><script type=\"math/tex\" id=\"MathJax-Element-6\">i</script> can be defined through <span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><span class=\"MathJax\" id=\"MathJax-Element-7-Frame\"><nobr><span class=\"math\" id=\"MathJax-Span-36\" role=\"math\" style=\"width: 3.158em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.622em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.61em 1000.003em 3.039em -999.997em); top: -2.557em; left: 0.003em;\"><span class=\"mrow\" id=\"MathJax-Span-37\"><span class=\"munderover\" id=\"MathJax-Span-38\"><span style=\"display: inline-block; position: relative; width: 1.193em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.039em 1000.003em 4.408em -999.997em); top: -3.985em; left: 0.003em;\"><span class=\"mo\" id=\"MathJax-Span-39\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 3.991em;\"></span></span><span style=\"position: absolute; top: -3.688em; left: 0.896em;\"><span class=\"mi\" id=\"MathJax-Span-40\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 3.991em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-41\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.182em;\">l<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-42\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-43\" style=\"font-family: STIXGeneral-Italic;\">i</span><span class=\"mo\" id=\"MathJax-Span-44\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.562em;\"></span></span></span><span style=\"border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.432em; vertical-align: -0.425em;\"></span></span></nobr></span><script type=\"math/tex\" id=\"MathJax-Element-7\">\\sum_i l(i)</script> where <span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><span class=\"MathJax\" id=\"MathJax-Element-8-Frame\"><nobr><span class=\"math\" id=\"MathJax-Span-45\" role=\"math\" style=\"width: 1.551em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.253em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.729em 1000.003em 2.92em -999.997em); top: -2.557em; left: 0.003em;\"><span class=\"mrow\" id=\"MathJax-Span-46\"><span class=\"mi\" id=\"MathJax-Span-47\" style=\"font-family: STIXGeneral-Italic;\">l<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-48\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-49\" style=\"font-family: STIXGeneral-Italic;\">i</span><span class=\"mo\" id=\"MathJax-Span-50\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.562em;\"></span></span></span><span style=\"border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.146em; vertical-align: -0.282em;\"></span></span></nobr></span><script type=\"math/tex\" id=\"MathJax-Element-8\">l(i)</script> is some local loss. In Wolfe such terms can be formulated using the <code>sum(range)(body)</code> operator that represents the sum <span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-9-Frame\"><nobr><span class=\"math\" id=\"MathJax-Span-51\" role=\"math\" style=\"width: 6.551em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 5.42em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.432em 1000.003em 4.11em -999.997em); top: -2.557em; left: 0.003em;\"><span class=\"mrow\" id=\"MathJax-Span-52\"><span class=\"munderover\" id=\"MathJax-Span-53\"><span style=\"display: inline-block; position: relative; width: 2.324em; height: 0px;\"><span style=\"position: absolute; clip: rect(2.86em 1000.003em 4.646em -999.997em); top: -3.985em; left: 0.539em;\"><span class=\"mo\" id=\"MathJax-Span-54\" style=\"font-family: STIXSizeOneSym; vertical-align: -0.533em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 3.991em;\"></span></span><span style=\"position: absolute; clip: rect(3.336em 1000.003em 4.408em -999.997em); top: -2.854em; left: 0.003em;\"><span class=\"texatom\" id=\"MathJax-Span-55\"><span class=\"mrow\" id=\"MathJax-Span-56\"><span class=\"mi\" id=\"MathJax-Span-57\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span class=\"mo\" id=\"MathJax-Span-58\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∈</span><span class=\"texatom\" id=\"MathJax-Span-59\"><span class=\"mrow\" id=\"MathJax-Span-60\"><span class=\"mi\" id=\"MathJax-Span-61\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">r</span><span class=\"mi\" id=\"MathJax-Span-62\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">a</span><span class=\"mi\" id=\"MathJax-Span-63\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">n</span><span class=\"mi\" id=\"MathJax-Span-64\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">g</span><span class=\"mi\" id=\"MathJax-Span-65\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 3.991em;\"></span></span></span></span><span class=\"texatom\" id=\"MathJax-Span-66\" style=\"padding-left: 0.182em;\"><span class=\"mrow\" id=\"MathJax-Span-67\"><span class=\"mi\" id=\"MathJax-Span-68\" style=\"font-family: STIXGeneral-Italic;\">b</span><span class=\"mi\" id=\"MathJax-Span-69\" style=\"font-family: STIXGeneral-Italic;\">o</span><span class=\"mi\" id=\"MathJax-Span-70\" style=\"font-family: STIXGeneral-Italic;\">d</span><span class=\"mi\" id=\"MathJax-Span-71\" style=\"font-family: STIXGeneral-Italic;\">y</span></span></span><span class=\"mo\" id=\"MathJax-Span-72\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-73\" style=\"font-family: STIXGeneral-Italic;\">i</span><span class=\"mo\" id=\"MathJax-Span-74\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.562em;\"></span></span></span><span style=\"border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 3.004em; vertical-align: -1.711em;\"></span></span></nobr></span></div><script type=\"math/tex; mode=display\" id=\"MathJax-Element-9\">\\sum_{i \\in \\mathit{range}} \\mathit{body}(i)</script> where <code>body</code> is a function from the element domain of <code>range</code> to the domain <code>Doubles</code> of reals. </p><p>A simple example of an applied <code>sum</code> operator can be used to count the number of <code>true</code> elements in a sequence of Booleans. </p>"
    }
  }, {
    "id" : 30,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val s = Seqs(Bools,3).Var\nval n = Ints(0 until 4).Var\nval count = sum(0 until n) { i => I(s(i))}\ncount",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor\",\"or.eval(x := false, y := true)\",\"I(or).eval(x := false, y := true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0).eval(b := false, x := 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1).eval(i := 5)\",\"val x = Vectors(2).Var\\n(x dot x).eval(x := vector(1,2))\",\" val s = Seqs(Bools,0,2).Var\\n val i = Ints(0 until 2).Var\\n s(i).eval(s := IndexedSeq(false,true),i := 1)\",\"s.length.eval(s := IndexedSeq(false))\",\"val m = Maps(Bools,Doubles).Var\\nval k = Bools.Var\\nm(k).eval(m := Map(true -> 1.0, false -> 2.0),k := false)\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div id=\"term37106714-ee39-4374-93e4-c217d9325e48\" class=\"term\">\n<svg width=\"960\" height=\"350\"><g transform=\"translate(120,40)\"><path class=\"link\" d=\"M210.9090909090909,100C210.9090909090909,125 184.54545454545453,125 184.54545454545453,150\"></path><path class=\"link\" d=\"M210.9090909090909,100C210.9090909090909,125 237.27272727272728,125 237.27272727272728,150\"></path><path class=\"link\" d=\"M210.9090909090909,50C210.9090909090909,75 210.9090909090909,75 210.9090909090909,100\"></path><path class=\"link\" d=\"M79.0909090909091,50C79.0909090909091,75 52.72727272727273,75 52.72727272727273,100\"></path><path class=\"link\" d=\"M79.0909090909091,50C79.0909090909091,75 105.45454545454545,75 105.45454545454545,100\"></path><path class=\"link\" d=\"M145,0C145,25 79.0909090909091,25 79.0909090909091,50\"></path><path class=\"link\" d=\"M145,0C145,25 210.9090909090909,25 210.9090909090909,50\"></path><g class=\"node\" transform=\"translate(237.27272727272728,150)\"><circle r=\"10\"></circle><text y=\"18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">_i</text></g><g class=\"node\" transform=\"translate(184.54545454545453,150)\"><circle r=\"10\"></circle><text y=\"18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">s </text></g><g class=\"node\" transform=\"translate(210.9090909090909,100)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">VarSeqApply</text></g><g class=\"node\" transform=\"translate(210.9090909090909,50)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">Iverson</text></g><g class=\"node\" transform=\"translate(105.45454545454545,100)\"><circle r=\"10\"></circle><text y=\"18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">n </text></g><g class=\"node\" transform=\"translate(52.72727272727273,100)\"><circle r=\"10\"></circle><text y=\"18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">0</text></g><g class=\"node\" transform=\"translate(79.0909090909091,50)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">RangeTerm</text></g><g class=\"node\" transform=\"translate(145,0)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">FirstOrderSum</text></g></g></svg>\n</div>\n<script>\n\nvar treeData = [\n\n{\n  \"name\": \"FirstOrderSum\",\n  \"parent\": \"null\",\n  \"children\": [\n{\n  \"name\": \"RangeTerm\",\n  \"parent\": \"FirstOrderSum\",\n  \"children\": [\n{\n  \"name\": \"0\",\n  \"parent\": \"RangeTerm\",\n  \"children\": []\n}\n             ,\n\n{\n  \"name\": \"n \",\n  \"parent\": \"RangeTerm\",\n  \"children\": []\n}\n             ]\n}\n             ,\n\n{\n  \"name\": \"Iverson\",\n  \"parent\": \"FirstOrderSum\",\n  \"children\": [\n{\n  \"name\": \"VarSeqApply\",\n  \"parent\": \"Iverson\",\n  \"children\": [\n{\n  \"name\": \"s \",\n  \"parent\": \"VarSeqApply\",\n  \"children\": []\n}\n             ,\n\n{\n  \"name\": \"_i\",\n  \"parent\": \"VarSeqApply\",\n  \"children\": []\n}\n             ]\n}\n             ]\n}\n             ]\n}\n\n];\n\nvar depth = 4 + 1\n\n// ************** Generate the tree diagram\t *****************\nvar margin = {top: 40, right: 120, bottom: 20, left: 120},\n\twidth = 960 - margin.right - margin.left,\n\theight = depth * 70 - margin.top - margin.bottom;\n\nvar i = 0;\n\nvar tree = d3.layout.tree()\n\t.size([height, width]);\n\nvar diagonal = d3.svg.diagonal()\n\t.projection(function(d) { return [d.x, d.y]; });\n\nvar svg = d3.select(\"#term37106714-ee39-4374-93e4-c217d9325e48 svg\")\n\t.attr(\"width\", width + margin.right + margin.left)\n\t.attr(\"height\", height + margin.top + margin.bottom)\n  .append(\"g\")\n\t.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\nroot = treeData[0];\n\nupdate(root);\n\nfunction update(source) {\n\n  // Compute the new tree layout.\n  var nodes = tree.nodes(source).reverse(),\n\t links = tree.links(nodes);\n\n  // Normalize for fixed-depth.\n  nodes.forEach(function(d) { d.y = d.depth * 50; });\n\n  // Declare the nodes…\n  var node = svg.selectAll(\"g.node\")\n\t  .data(nodes, function(d) { return d.id || (d.id = ++i); });\n\n  // Enter the nodes.\n  var nodeEnter = node.enter().append(\"g\")\n\t  .attr(\"class\", \"node\")\n\t  .attr(\"transform\", function(d) {\n\t\t  return \"translate(\" + d.x + \",\" + d.y + \")\"; });\n\n  nodeEnter.append(\"circle\")\n\t  .attr(\"r\", 10);\n\n  nodeEnter.append(\"text\")\n\t  .attr(\"y\", function(d) {\n\t\t  return d.children || d._children ? -18 : 18; })\n\t  .attr(\"dy\", \".35em\")\n\t  .attr(\"text-anchor\", \"middle\")\n\t  .text(function(d) { return d.name; })\n\t  .style(\"fill-opacity\", 1);\n\n  // Declare the links…\n  var link = svg.selectAll(\"path.link\")\n\t  .data(links, function(d) { return d.target.id; });\n\n  // Enter the links.\n  link.enter().insert(\"path\", \"g\")\n\t  .attr(\"class\", \"link\")\n\t  .attr(\"d\", diagonal);\n\n}\n\n</script></div>"
    }
  }, {
    "id" : 31,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "count.eval(s := IndexedSeq(true,true,true), n := 2)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor\",\"or.eval(x := false, y := true)\",\"I(or).eval(x := false, y := true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0).eval(b := false, x := 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1).eval(i := 5)\",\"val x = Vectors(2).Var\\n(x dot x).eval(x := vector(1,2))\",\" val s = Seqs(Bools,0,2).Var\\n val i = Ints(0 until 2).Var\\n s(i).eval(s := IndexedSeq(false,true),i := 1)\",\"s.length.eval(s := IndexedSeq(false))\",\"val m = Maps(Bools,Doubles).Var\\nval k = Bools.Var\\nm(k).eval(m := Map(true -> 1.0, false -> 2.0),k := false)\",\"val s = Seqs(Bools,3).Var\\nval n = Ints(0 until 4).Var\\nval count = sum(0 until n) { i => I(s(i))}\\ncount\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">2.0</span></div>"
    }
  }, {
    "id" : 32,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Constraints\n\nOften real-value functions need to be defined over a *constrained* subset of the original domain. In Wolfe this can be achieved using the `term.subjectTo(predicate)` operator on real-valued terms. This operator returns \\\\(-\\infty\\\\) if the `predicate` term evaluates to `false` and the value of `term` otherwise.   ",
      "extraFields" : { },
      "outputFormat" : "<h3>Constraints</h3><p>Often real-value functions need to be defined over a <em>constrained</em> subset of the original domain. In Wolfe this can be achieved using the <code>term.subjectTo(predicate)</code> operator on real-valued terms. This operator returns <span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><span class=\"MathJax\" id=\"MathJax-Element-10-Frame\"><nobr><span class=\"math\" id=\"MathJax-Span-75\" role=\"math\" style=\"width: 2.027em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.67em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.967em 1000.003em 2.741em -999.997em); top: -2.557em; left: 0.003em;\"><span class=\"mrow\" id=\"MathJax-Span-76\"><span class=\"mo\" id=\"MathJax-Span-77\" style=\"font-family: STIXGeneral-Regular;\">−</span><span class=\"mi\" id=\"MathJax-Span-78\" style=\"font-family: STIXGeneral-Regular;\">∞</span></span><span style=\"display: inline-block; width: 0px; height: 2.562em;\"></span></span></span><span style=\"border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.646em; vertical-align: -0.068em;\"></span></span></nobr></span><script type=\"math/tex\" id=\"MathJax-Element-10\">-\\infty</script> if the <code>predicate</code> term evaluates to <code>false</code> and the value of <code>term</code> otherwise. </p>"
    }
  }, {
    "id" : 33,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val x = Doubles.Var\nval y = Ints.Var\n(x subjectTo (y === 3)).eval(x := 2.0, y := 2)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor\",\"or.eval(x := false, y := true)\",\"I(or).eval(x := false, y := true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0).eval(b := false, x := 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1).eval(i := 5)\",\"val x = Vectors(2).Var\\n(x dot x).eval(x := vector(1,2))\",\" val s = Seqs(Bools,0,2).Var\\n val i = Ints(0 until 2).Var\\n s(i).eval(s := IndexedSeq(false,true),i := 1)\",\"s.length.eval(s := IndexedSeq(false))\",\"val m = Maps(Bools,Doubles).Var\\nval k = Bools.Var\\nm(k).eval(m := Map(true -> 1.0, false -> 2.0),k := false)\",\"val s = Seqs(Bools,3).Var\\nval n = Ints(0 until 4).Var\\nval count = sum(0 until n) { i => I(s(i))}\\ncount\",\"count.eval(s := IndexedSeq(true,true,true), n := 2)\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">-Infinity</span></div>"
    }
  }, {
    "id" : 34,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Term Types\n\nScala programs in general, and Wolfe terms in particular, are type-safe. That is, before you can execute code, the compiler will complain when you try to add two objects which aren't numbers, or when you try to access the i-th element of a term that isn't a sequence. This avoids many problems that only emerge at runtime in dynamic languages. However in Wolfe it also means that you need to explicitly type the arguments of methods that operate on terms to create new terms, and this can quickly get out of hand if you work with generic types (where types themselves have other types as parameters).  \n\nFor example, imagine you want to write a method that creates a term representing the number of verbs in a sentence, as shown below. With generic types the `count` method would require the input type `VarSeqDom[Tuple2Dom[DiscreteDom[String],DiscreteDom[String]]]#Term`. To avoid such long signatures, in Wolfe each domain has a type member `Term` that refers to the type of terms the domain provides. This allows the `count` signature to be much more concise by using `Sentences.Term` as input type.             ",
      "extraFields" : { },
      "outputFormat" : "<h3>Term Types</h3><p>Scala programs in general, and Wolfe terms in particular, are type-safe. That is, before you can execute code, the compiler will complain when you try to add two objects which aren't numbers, or when you try to access the i-th element of a term that isn't a sequence. This avoids many problems that only emerge at runtime in dynamic languages. However in Wolfe it also means that you need to explicitly type the arguments of methods that operate on terms to create new terms, and this can quickly get out of hand if you work with generic types (where types themselves have other types as parameters). </p><p>For example, imagine you want to write a method that creates a term representing the number of verbs in a sentence, as shown below. With generic types the <code>count</code> method would require the input type <code>VarSeqDom[Tuple2Dom[DiscreteDom[String],DiscreteDom[String]]]#Term</code>. To avoid such long signatures, in Wolfe each domain has a type member <code>Term</code> that refers to the type of terms the domain provides. This allows the <code>count</code> signature to be much more concise by using <code>Sentences.Term</code> as input type. </p>"
    }
  }, {
    "id" : 35,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val Words = List(\"the\",\"cat\",\"sat\").toDom\nval Tags = List(\"DT\",\"NN\",\"VBD\").toDom\nval Tokens = Pairs(Words,Tags)\nval Sentences = Seqs(Tokens,0,3)\nval s = Sentences.Var\n\ndef count(s:Sentences.Term) = \n  sum(s){ t => I(t._1 === Tags.Const(\"VBD\")) }\n\ncount(s).eval(s := IndexedSeq(\"the\"->\"DT\",\"cat\" -> \"NN\", \"sat\" -> \"VBD\"))    ",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb.eval(b := true)\",\"val s = Seqs(Bools,2).Var\\ns.eval(s := IndexedSeq(false,true))\",\"Bools.Const(true)\",\"Bools.Const(true).eval()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt.eval()\",\"val d:DoubleTerm = 1.0\\nd.eval()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor\",\"or.eval(x := false, y := true)\",\"I(or).eval(x := false, y := true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0).eval(b := false, x := 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1).eval(i := 5)\",\"val x = Vectors(2).Var\\n(x dot x).eval(x := vector(1,2))\",\" val s = Seqs(Bools,0,2).Var\\n val i = Ints(0 until 2).Var\\n s(i).eval(s := IndexedSeq(false,true),i := 1)\",\"s.length.eval(s := IndexedSeq(false))\",\"val m = Maps(Bools,Doubles).Var\\nval k = Bools.Var\\nm(k).eval(m := Map(true -> 1.0, false -> 2.0),k := false)\",\"val s = Seqs(Bools,3).Var\\nval n = Ints(0 until 4).Var\\nval count = sum(0 until n) { i => I(s(i))}\\ncount\",\"count.eval(s := IndexedSeq(true,true,true), n := 2)\",\"val x = Doubles.Var\\nval y = Ints.Var\\n(x subjectTo (y === 3)).eval(x := 2.0, y := 2)\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">1.0</span></div>"
    }
  } ],
  "config" : { }
}
