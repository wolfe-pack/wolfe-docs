{
  "name" : "Terms",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Our goal is to compose mathematical objectives of the form \n\\\\(f:\\mathcal{S}\\mapsto\\mathbb{R}\\\\). Being able to define the domains \\\\(\\mathcal{S}\\\\) we can now go on to construct \\\\(f\\\\). In Wolfe this is done by constructing the _term_ \\\\(f(s)\\\\) that represents the function applied to an element \\\\(s \\in \\mathcal{S}\\\\). \n\nTerms in wolfe are represented through the `Term` trait. Each `Term` object has a domain, and _evaluates_ to a value in this domain based on an assignment to the free variables in the term. The way a term evaluates to a value defines the term's semantics. You can test what a term `t` evaluates to by calling `t(freeVar1 << value1, freeVar2 << value2, ...)`. \n\nTerms are constructed using the Wolfe Term DSL. Here basic term primitives, such as variables and  constants can be composed into complex mathematical objectives using constructs such as sequence or map accessors, plus and sum operators and even argmax expressions. The Wolfe Term DSL attempts to be as close as possible to Scala syntax, and hence often Wolfe Terms will look like standard scala expressions. However, it is important to point out that they are symbolic descriptions that define some computation, and they can be analyzed at runtime to derive gradients, maximization algorithms etc.  \n\nIn the following we will present a range of primitive and more complex terms.\n",
      "extraFields" : {
        "aggregatedCells" : "[]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 1,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Variables",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "One of the the simplest types of terms are _variables_. The value of a variable is the value assigned to this variable in a given binding. To construct a variable, you can use the `Var` constructor defined on domains. ",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 3,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "val b = Bools.Var\nb(b << true)",
      "extraFields" : {
        "aggregatedCells" : "[]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 4,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "It's worthwhile noting that variables can also be created for complex structured domains.",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 5,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "val s = Seqs(Bools,2).Var\ns(s << IndexedSeq(false,true))",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 6,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Constants",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 7,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Constants are terms that always evaluate to the same value. To create a constant of a given domain you can call the domain's `Const` method.",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 8,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "val b = Bools.Const(true)\nb()",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 9,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "You can avoid an explicit mention of the domain by introducing the domain as `implicit` value. Now every time you call `toConst` on a value of this domain, the matching `Const` constructor is implicitly called.",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 10,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "implicit val Instances = Seqs(Bools,2)\nval t = Seq(false,true).toConst\nt()",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\",\"val b = Bools.Const(true)\\nb()\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 11,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "For primitive types such as `Double`, `Boolean` and `Int` Wolfe provides direct conversions from values to constants.",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 12,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "val d:DoubleTerm = 1.0\nd()",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\",\"val b = Bools.Const(true)\\nb()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt()\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 13,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Boolean Operators",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 14,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Boolean variables and constants can be composed using boolean functions. Wolfe provides the standard Scala operations on Booleans, as well as implication `-->` and equivalence `<->` to build models of probabilistic logic. ",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 15,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "val x = Bools.Var\nval y = Bools.Var\nval or = (x || y)\nor(x << false, y << true)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\",\"val b = Bools.Const(true)\\nb()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt()\",\"val d:DoubleTerm = 1.0\\nd()\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 16,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "When creating objectives, in particular over discrete spaces, one often needs to convert boolean experssion to double expressions. For this Wolfe provides the [Iverson Bracket](http://en.wikipedia.org/wiki/Iverson_bracket) operator `I(x)`. It evaluates to `1.0` if the inner term `x` evaluates to `true` and `0.0` otherwise.",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 17,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "I(or)(x << false, y << true)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\",\"val b = Bools.Const(true)\\nb()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt()\",\"val d:DoubleTerm = 1.0\\nd()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor(x << false, y << true)\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 18,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Numeric Operators",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 19,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "The final goal of modelling in Wolfe is to build functions from search or sample spaces to real values. Naturally Wolfe hence provides a range of functions to compose complex real terms from simpler ones, such as addition, multiplication and the `log` operator.   ",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 20,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "val b = Bools.Var\nval x = Doubles.Var\nlog(x + I(b) * 2.0)(b << false, x << 2.0)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\",\"val b = Bools.Const(true)\\nb()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt()\",\"val d:DoubleTerm = 1.0\\nd()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor(x << false, y << true)\",\"I(or)(x << false, y << true)\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 21,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Likewise, Wolfe provides the common operations on integers one would expect.  ",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 22,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "val i = Ints.Var\n(i * 2 - 1)(i << 5)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\",\"val b = Bools.Const(true)\\nb()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt()\",\"val d:DoubleTerm = 1.0\\nd()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor(x << false, y << true)\",\"I(or)(x << false, y << true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0)(b << false, x << 2.0)\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 37,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Vector Operators",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 38,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Parameter vectors, layers of neural networks and word-embeddings are examples of vector representations. To facilitate working with such representations, Wolfe provides many standard operators on vectors, e.g. dot products, matrix-vector multiplications or simply component-wise \napplications of real-valued functions.",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 39,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "val x = Vectors(2).Var\n(x dot x)(x << vector(1,2))",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\",\"val b = Bools.Const(true)\\nb()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt()\",\"val d:DoubleTerm = 1.0\\nd()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor(x << false, y << true)\",\"I(or)(x << false, y << true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0)(b << false, x << 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1)(i << 5)\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 23,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Sequence Terms",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 24,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "We have earlier introduced sequence domains. Terms of sequences, such as sequence variables or constants, provide an element accessor operator `s(i)` that returns a term representing the `i`th element of the sequence represented by `s`.   ",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 25,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : " val s = Seqs(Bools,0,2).Var\n val i = Ints(0 until 2).Var\n s(i)(s << IndexedSeq(false,true),i << 1)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\",\"val b = Bools.Const(true)\\nb()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt()\",\"val d:DoubleTerm = 1.0\\nd()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor(x << false, y << true)\",\"I(or)(x << false, y << true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0)(b << false, x << 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1)(i << 5)\",\"val x = Vectors(2).Var\\n(x dot x)(x << vector(1,2))\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 26,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Via the `length` method you can also create a term representing the length of a sequence. ",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 27,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "s.length(s << IndexedSeq(false))",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\",\"val b = Bools.Const(true)\\nb()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt()\",\"val d:DoubleTerm = 1.0\\nd()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor(x << false, y << true)\",\"I(or)(x << false, y << true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0)(b << false, x << 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1)(i << 5)\",\"val x = Vectors(2).Var\\n(x dot x)(x << vector(1,2))\",\" val s = Seqs(Bools,0,2).Var\\n val i = Ints(0 until 2).Var\\n s(i)(s << IndexedSeq(false,true),i << 1)\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 28,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Map Terms",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 29,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Map terms support access to the map's element via a key. ",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 30,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "val m = Maps(Bools,Doubles).Var\nval k = Bools.Var\nm(k)(m << Map(true -> 1.0, false -> 2.0),k << false)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\",\"val b = Bools.Const(true)\\nb()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt()\",\"val d:DoubleTerm = 1.0\\nd()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor(x << false, y << true)\",\"I(or)(x << false, y << true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0)(b << false, x << 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1)(i << 5)\",\"val x = Vectors(2).Var\\n(x dot x)(x << vector(1,2))\",\" val s = Seqs(Bools,0,2).Var\\n val i = Ints(0 until 2).Var\\n s(i)(s << IndexedSeq(false,true),i << 1)\",\"s.length(s << IndexedSeq(false))\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 31,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Quantified Sums",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 32,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Sequence and map domains allow users to compactly define structured search spaces. Most of the time objectives on such spaces have a very repetitive (additive) structure, and can hence be defined compactly as well. For example, a training objective of instances \\\\(i\\\\) can be defined through \\\\(\\sum_i l(i)\\\\) where \\\\(l(i)\\\\) is some local loss. In Wolfe such terms can be formulated using the `sum(range)(body)` operator that represents the sum \n$$\\sum_{i \\in \\mathit{range}} \\mathit{body}(i)$$\nwhere `body` is a function from the element domain of `range` to the domain `Doubles` of reals. \n\nA simple example of an applied `sum` operator can be used to count the number of `true` elements in a sequence of Booleans.  \n",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 33,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "val s = Seqs(Bools,3).Var\nval count = sum(0 until 3) { i => I(s(i))}\ncount(s << IndexedSeq(true,true,true))",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\",\"val b = Bools.Const(true)\\nb()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt()\",\"val d:DoubleTerm = 1.0\\nd()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor(x << false, y << true)\",\"I(or)(x << false, y << true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0)(b << false, x << 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1)(i << 5)\",\"val x = Vectors(2).Var\\n(x dot x)(x << vector(1,2))\",\" val s = Seqs(Bools,0,2).Var\\n val i = Ints(0 until 2).Var\\n s(i)(s << IndexedSeq(false,true),i << 1)\",\"s.length(s << IndexedSeq(false))\",\"val m = Maps(Bools,Doubles).Var\\nval k = Bools.Var\\nm(k)(m << Map(true -> 1.0, false -> 2.0),k << false)\"]"
      },
      "outputFormat" : null
    }
  }, {
    "id" : 34,
    "compiler" : "heading3",
    "input" : {
      "sessionId" : null,
      "code" : "Constraints",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 35,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Often real-value functions need to be defined over a *constrained* subset of the original domain. In Wolfe this can be achieved using the `term.subjectTo(predicate)` operator on real-valued terms. This operator returns \\\\(-\\infty\\\\) if the `predicate` term evaluates to `false` and the value of `term` otherwise.   ",
      "extraFields" : { },
      "outputFormat" : null
    }
  }, {
    "id" : 36,
    "compiler" : "wolfe",
    "input" : {
      "sessionId" : null,
      "code" : "val x = Doubles.Var\nval y = Ints.Var\n(x subjectTo (y === 3))(x << 2.0, y << 2)",
      "extraFields" : {
        "aggregatedCells" : "[\"val b = Bools.Var\\nb(b << true)\",\"val s = Seqs(Bools,2).Var\\ns(s << IndexedSeq(false,true))\",\"val b = Bools.Const(true)\\nb()\",\"implicit val Instances = Seqs(Bools,2)\\nval t = Seq(false,true).toConst\\nt()\",\"val d:DoubleTerm = 1.0\\nd()\",\"val x = Bools.Var\\nval y = Bools.Var\\nval or = (x || y)\\nor(x << false, y << true)\",\"I(or)(x << false, y << true)\",\"val b = Bools.Var\\nval x = Doubles.Var\\nlog(x + I(b) * 2.0)(b << false, x << 2.0)\",\"val i = Ints.Var\\n(i * 2 - 1)(i << 5)\",\"val x = Vectors(2).Var\\n(x dot x)(x << vector(1,2))\",\" val s = Seqs(Bools,0,2).Var\\n val i = Ints(0 until 2).Var\\n s(i)(s << IndexedSeq(false,true),i << 1)\",\"s.length(s << IndexedSeq(false))\",\"val m = Maps(Bools,Doubles).Var\\nval k = Bools.Var\\nm(k)(m << Map(true -> 1.0, false -> 2.0),k << false)\",\"val s = Seqs(Bools,3).Var\\nval count = sum(0 until 3) { i => I(s(i))}\\ncount(s << IndexedSeq(true,true,true))\"]"
      },
      "outputFormat" : null
    }
  } ],
  "config" : { }
}
