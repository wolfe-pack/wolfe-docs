{
  "name" : "Dependency Parsing",
  "cells" : [ {
    "id" : 0,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import DepParseExample._\nimplicit val index = new SimpleIndex()\nimplicit val params = BPParameters(2, BP.Schedule.synchronized)\n\nval maxLength = 10\nval maxFeats = 1000\n\n@domain case class Sentence(word: IndexedSeq[String], pos: IndexedSeq[String])\n\nval s1 = Sentence(Vector(\"ROOT\", \"a\", \"cat\", \"sat\", \"on\", \"the\", \"mat\"), Vector(\"ROOT\", \"DT\", \"NN\", \"VBD\", \"IN\", \"DT\", \"NN\"))\nval sentences = Seq(s1)\n\nimplicit val Thetas = Vectors(maxFeats)\nimplicit val Words = sentences.flatMap(_.word).distinct.toDom\nimplicit val Tags = sentences.flatMap(_.pos).distinct.toDom\nimplicit val Sentences = Sentence.Objects(Seqs(Words, 0, maxLength), Seqs(Tags, 0, maxLength))\nimplicit val Parses = Seqs(Seqs(Bools, 0, maxLength), 0, maxLength)\n\nval theta = zeros + weight('pos_00, 1.0, Tags.Const(\"NN\"), Tags.Const(\"DT\"), true)\n\ndef features(x: Sentences.Term, y: Parses.Term, head: IntTerm, mod: IntTerm) = \n  feature('pos_00, x.pos(head), x.pos(mod), y(mod)(head))\n\nfeatures(Sentences.Variable(\"x\"),Parses.Variable(\"y\"),Ints.Variable(\"h\"),Ints.Variable(\"m\"))",
      "extraFields" : {
        "aggregatedCells" : "[]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"label label-danger\">Error!</span>\n<pre class=\"error\"><console>:70: error: not found: value zeros\n              val theta = zeros + weight('pos_00, 1.0, Tags.Const(\"NN\"), Tags.Const(\"DT\"), true)\n                          ^\n<console>:70: error: not found: value weight\n              val theta = zeros + weight('pos_00, 1.0, Tags.Const(\"NN\"), Tags.Const(\"DT\"), true)\n                                  ^\n</console></console></pre></div>"
    }
  }, {
    "id" : 1,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def linear(t: Thetas.Term, x: Sentences.Term, y: Parses.Term) = \n  sum(0 until x.word.length) { head =>\n    sum(1 until x.word.length) { mod =>\n      t dot features(x, y, head, mod)\n    }\n  }\n  \ndef model(t: Thetas.Term, x: Sentences.Term, y: Parses.Term) =\n  linear(t, x, y)\n\nval margs = marginals(Parses) { y => model(theta, s1.toConst, y) marginalsBy Marginalizer.sumProduct }\n\ntoMatrix(s1.word, margs.eval())",
      "extraFields" : {
        "aggregatedCells" : "[\"import DepParseExample._\\nimplicit val index = new SimpleIndex()\\nimplicit val params = BPParameters(2, BP.Schedule.synchronized)\\n\\nval maxLength = 10\\nval maxFeats = 1000\\n\\n@domain case class Sentence(word: IndexedSeq[String], pos: IndexedSeq[String])\\n\\nval s1 = Sentence(Vector(\\\"ROOT\\\", \\\"a\\\", \\\"cat\\\", \\\"sat\\\", \\\"on\\\", \\\"the\\\", \\\"mat\\\"), Vector(\\\"ROOT\\\", \\\"DT\\\", \\\"NN\\\", \\\"VBD\\\", \\\"IN\\\", \\\"DT\\\", \\\"NN\\\"))\\nval sentences = Seq(s1)\\n\\nimplicit val Thetas = Vectors(maxFeats)\\nimplicit val Words = sentences.flatMap(_.word).distinct.toDom\\nimplicit val Tags = sentences.flatMap(_.pos).distinct.toDom\\nimplicit val Sentences = Sentence.Objects(Seqs(Words, 0, maxLength), Seqs(Tags, 0, maxLength))\\nimplicit val Parses = Seqs(Seqs(Bools, 0, maxLength), 0, maxLength)\\n\\nval theta = zeros + weight('pos_00, 1.0, Tags.Const(\\\"NN\\\"), Tags.Const(\\\"DT\\\"), true)\\n\\ndef features(x: Sentences.Term, y: Parses.Term, head: IntTerm, mod: IntTerm) = \\n  feature('pos_00, x.pos(head), x.pos(mod), y(mod)(head))\\n\\nfeatures(Sentences.Variable(\\\"x\\\"),Parses.Variable(\\\"y\\\"),Ints.Variable(\\\"h\\\"),Ints.Variable(\\\"m\\\"))\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"label label-danger\">Error!</span>\n<pre class=\"error\"><console>:70: error: not found: value zeros\n              val theta = zeros + weight('pos_00, 1.0, Tags.Const(\"NN\"), Tags.Const(\"DT\"), true)\n                          ^\n<console>:70: error: not found: value weight\n              val theta = zeros + weight('pos_00, 1.0, Tags.Const(\"NN\"), Tags.Const(\"DT\"), true)\n                                  ^\n</console></console></pre></div>"
    }
  }, {
    "id" : 2,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def model(t: Thetas.Term, x: Sentences.Term, y: Parses.Term) =\n  linear(t, x, y) subjectTo projectiveTree(y, x.word.length)\n\nval margs = marginals(Parses) { y => model(theta, s1.toConst, y) marginalsBy Marginalizer.sumProduct }\n\ntoMatrix(s1.word, margs.eval())",
      "extraFields" : {
        "aggregatedCells" : "[\"import DepParseExample._\\nimplicit val index = new SimpleIndex()\\nimplicit val params = BPParameters(2, BP.Schedule.synchronized)\\n\\nval maxLength = 10\\nval maxFeats = 1000\\n\\n@domain case class Sentence(word: IndexedSeq[String], pos: IndexedSeq[String])\\n\\nval s1 = Sentence(Vector(\\\"ROOT\\\", \\\"a\\\", \\\"cat\\\", \\\"sat\\\", \\\"on\\\", \\\"the\\\", \\\"mat\\\"), Vector(\\\"ROOT\\\", \\\"DT\\\", \\\"NN\\\", \\\"VBD\\\", \\\"IN\\\", \\\"DT\\\", \\\"NN\\\"))\\nval sentences = Seq(s1)\\n\\nimplicit val Thetas = Vectors(maxFeats)\\nimplicit val Words = sentences.flatMap(_.word).distinct.toDom\\nimplicit val Tags = sentences.flatMap(_.pos).distinct.toDom\\nimplicit val Sentences = Sentence.Objects(Seqs(Words, 0, maxLength), Seqs(Tags, 0, maxLength))\\nimplicit val Parses = Seqs(Seqs(Bools, 0, maxLength), 0, maxLength)\\n\\nval theta = zeros + weight('pos_00, 1.0, Tags.Const(\\\"NN\\\"), Tags.Const(\\\"DT\\\"), true)\\n\\ndef features(x: Sentences.Term, y: Parses.Term, head: IntTerm, mod: IntTerm) = \\n  feature('pos_00, x.pos(head), x.pos(mod), y(mod)(head))\\n\\nfeatures(Sentences.Variable(\\\"x\\\"),Parses.Variable(\\\"y\\\"),Ints.Variable(\\\"h\\\"),Ints.Variable(\\\"m\\\"))\",\"def linear(t: Thetas.Term, x: Sentences.Term, y: Parses.Term) = \\n  sum(0 until x.word.length) { head =>\\n    sum(1 until x.word.length) { mod =>\\n      t dot features(x, y, head, mod)\\n    }\\n  }\\n  \\ndef model(t: Thetas.Term, x: Sentences.Term, y: Parses.Term) =\\n  linear(t, x, y)\\n\\nval margs = marginals(Parses) { y => model(theta, s1.toConst, y) marginalsBy Marginalizer.sumProduct }\\n\\ntoMatrix(s1.word, margs.eval())\"]"
      },
      "outputFormat" : "<div class=\"text-center\"><i class=\"fa fa-refresh fa-spin fa-lg\"></i></div>"
    }
  } ],
  "config" : { }
}
