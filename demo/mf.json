{
  "name" : "Relation Extraction with Matrix Factorization",
  "cells" : [ {
    "id" : 0,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//all entities\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\n\n//a Freebase relation\ndef employeeAt = Set('Petrie -> 'UCL)\n\n//visualization of knowledge graph\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))",
      "extraFields" : {
        "aggregatedCells" : "[]"
      },
      "outputFormat" : "<div class=\"string-result\"><div id=\"graphDivd7b00316-368a-42c2-86e7-69981ec4cec1\"><svg width=\"750\" height=\"450\"><g><rect width=\"750\" height=\"450\" style=\"opacity: 0;\"></rect><line class=\"link\" opacity=\"1\" style=\"stroke-width: 3.16227766016838px; stroke: rgb(136, 136, 136);\" x1=\"355.9774629644743\" y1=\"383.7827444336145\" x2=\"266.28152888849684\" y2=\"324.8459623169152\"><title>\"\"</title></line><g class=\"node\" transform=\"translate(311.4774358720038,89.19488384899641)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Cambridge\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Cambridge</text></g><g class=\"node\" transform=\"translate(355.9774629644743,383.7827444336145)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'UCL\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'UCL</text></g><g class=\"node\" transform=\"translate(513.272951333531,336.06548304675414)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Harvard\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Harvard</text></g><g class=\"node\" transform=\"translate(266.28152888849684,324.8459623169152)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Petrie\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Petrie</text></g><g class=\"node\" transform=\"translate(451.85352447675365,66.11608606658415)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Ferguson\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Ferguson</text></g><g class=\"node\" transform=\"translate(532.0153210336163,190.9680903956376)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Andrew\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Andrew</text></g><g class=\"node\" transform=\"translate(198.22145316940558,180.33863325489025)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Trevelyan\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Trevelyan</text></g></g></svg></div>\n\n<script type=\"text/javascript\">\n drawGraph({\"nodes\":[{\"name\":\"'Cambridge\",\"description\":\"'Cambridge\",\"value\":1.0,\"group\":0},{\"name\":\"'UCL\",\"description\":\"'UCL\",\"value\":1.0,\"group\":0},{\"name\":\"'Harvard\",\"description\":\"'Harvard\",\"value\":1.0,\"group\":0},{\"name\":\"'Petrie\",\"description\":\"'Petrie\",\"value\":1.0,\"group\":0},{\"name\":\"'Ferguson\",\"description\":\"'Ferguson\",\"value\":1.0,\"group\":0},{\"name\":\"'Andrew\",\"description\":\"'Andrew\",\"value\":1.0,\"group\":0},{\"name\":\"'Trevelyan\",\"description\":\"'Trevelyan\",\"value\":1.0,\"group\":0}],\"edges\":[{\"source\":1,\"target\":3,\"description\":\"\",\"value\":1.0,\"group\":0}],\"directed\":\"false\"}, \"graphDivd7b00316-368a-42c2-86e7-69981ec4cec1\");\n</script></div>"
    }
  }, {
    "id" : 1,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//some surface form relations\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\ndef museum_at = Set('Petrie -> 'UCL)\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\n\n//visualization of knowledge graph and surface forms\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div id=\"graphDivce063f11-56ff-48a1-9ead-207c2311fa22\"><svg width=\"750\" height=\"450\"><g><rect width=\"750\" height=\"450\" style=\"opacity: 0;\"></rect><line class=\"link\" opacity=\"1\" style=\"stroke-width: 3.16227766016838px; stroke: rgb(136, 136, 136);\" x1=\"439.16978406788877\" y1=\"91.87375029310198\" x2=\"332.1414685102059\" y2=\"76.77208888543748\"><title>\"\"</title></line><line class=\"link\" opacity=\"1\" style=\"stroke-width: 3.16227766016838px; stroke: rgb(136, 136, 136);\" x1=\"439.16978406788877\" y1=\"91.87375029310198\" x2=\"525.7360067501314\" y2=\"156.92086268549863\"><title>\"\"</title></line><line class=\"link\" opacity=\"1\" style=\"stroke-width: 3.16227766016838px; stroke: rgb(136, 136, 136);\" x1=\"238.42059825252852\" y1=\"312.91477152471975\" x2=\"214.94063078871014\" y2=\"206.64181840442163\"><title>\"\"</title></line><line class=\"link\" opacity=\"1\" style=\"stroke-width: 3.16227766016838px; stroke: rgb(136, 136, 136);\" x1=\"478.94098357514224\" y1=\"398.23586244917226\" x2=\"407.57423677871157\" y2=\"321.6963221675602\"><title>\"\"</title></line><g class=\"node\" transform=\"translate(439.16978406788877,91.87375029310198)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Cambridge\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Cambridge</text></g><g class=\"node\" transform=\"translate(238.42059825252852,312.91477152471975)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'UCL\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'UCL</text></g><g class=\"node\" transform=\"translate(478.94098357514224,398.23586244917226)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Harvard\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Harvard</text></g><g class=\"node\" transform=\"translate(214.94063078871014,206.64181840442163)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Petrie\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Petrie</text></g><g class=\"node\" transform=\"translate(407.57423677871157,321.6963221675602)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Ferguson\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Ferguson</text></g><g class=\"node\" transform=\"translate(332.1414685102059,76.77208888543748)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Andrew\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Andrew</text></g><g class=\"node\" transform=\"translate(525.7360067501314,156.92086268549863)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Trevelyan\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Trevelyan</text></g></g></svg></div>\n\n<script type=\"text/javascript\">\n drawGraph({\"nodes\":[{\"name\":\"'Cambridge\",\"description\":\"'Cambridge\",\"value\":1.0,\"group\":0},{\"name\":\"'UCL\",\"description\":\"'UCL\",\"value\":1.0,\"group\":0},{\"name\":\"'Harvard\",\"description\":\"'Harvard\",\"value\":1.0,\"group\":0},{\"name\":\"'Petrie\",\"description\":\"'Petrie\",\"value\":1.0,\"group\":0},{\"name\":\"'Ferguson\",\"description\":\"'Ferguson\",\"value\":1.0,\"group\":0},{\"name\":\"'Andrew\",\"description\":\"'Andrew\",\"value\":1.0,\"group\":0},{\"name\":\"'Trevelyan\",\"description\":\"'Trevelyan\",\"value\":1.0,\"group\":0}],\"edges\":[{\"source\":0,\"target\":5,\"description\":\"\",\"value\":1.0,\"group\":0},{\"source\":0,\"target\":6,\"description\":\"\",\"value\":1.0,\"group\":0},{\"source\":1,\"target\":3,\"description\":\"\",\"value\":1.0,\"group\":0},{\"source\":2,\"target\":4,\"description\":\"\",\"value\":1.0,\"group\":0}],\"directed\":\"false\"}, \"graphDivce063f11-56ff-48a1-9ead-207c2311fa22\");\n</script></div>"
    }
  }, {
    "id" : 2,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//all entity-pairs that will become the rows of our data matrix\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\n\n//convenience data structures\n//mapping from entities that appear as first arguments to their index\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\n\n//mapping from entities that appear as second arguments to their index\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\n\n//mapping from tuples to their argument indices\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\n\n//mapping from argument indices to entity-pair index\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\nargsIxToPairIx.asString",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\"]"
      },
      "outputFormat" : "<div class=\"string-result\">Map((0,0) -&gt; 0, (1,1) -&gt; 1, (2,2) -&gt; 2, (3,2) -&gt; 3)</div>"
    }
  }, {
    "id" : 3,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//all relations (structured and unstructured) that will become the columns of our data matrix\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\nargsIxToPairIx.asString\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div class=\"asIterable List\"><span class=\"typeName\">List</span>\n<ol start=\"0\" class=\"fields\">\n  <li class=\"fieldValue\"><span class=\"asString String\">'is_historian_at</span></li>\n  <li class=\"fieldValue\"><span class=\"asString String\">'is_professor_at</span></li>\n  <li class=\"fieldValue\"><span class=\"asString String\">'museum_at</span></li>\n  <li class=\"fieldValue\"><span class=\"asString String\">'teaches_history_at</span></li>\n  <li class=\"fieldValue\"><span class=\"asString String\">'employeeAt</span></li>\n</ol>\n</div></div>"
    }
  }, {
    "id" : 4,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//mapping from entity-pairs to their unique index\nval pairToPairIx = rows.zipWithIndex.toMap\n\nval data = List(is_historian_at, is_professor_at, museum_at, teaches_history_at, employeeAt).map(_.map(pairToPairIx))\n\n//training tuples (s, ij)\nval tuples = data.zipWithIndex.flatMap(t => t._1.map(pair => t._2 -> pair))\n\n//training triples (s, i, j)\nval triples = tuples.map(t => t._1 -> tupleToArgIndices(rows(t._2))).map(t => (t._1, t._2._1, t._2._2))\ntriples.asString",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\nargsIxToPairIx.asString\",\"//all relations (structured and unstructured) that will become the columns of our data matrix\\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)\"]"
      },
      "outputFormat" : "<div class=\"string-result\">List((0,1,1), (0,2,2), (1,0,0), (1,1,1), (1,3,2), (2,0,0), (3,3,2), (4,0,0))</div>"
    }
  }, {
    "id" : 5,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//visualization of the sparse data matrix\nMatrix((0 until rows.length).map(row => (0 until cols.length).map(col => if (data(col).contains(row)) 1.0 else 0.0).toSeq).toSeq, rows.map(t => t._1+\",\"+t._2), cols.map(_.toString))",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\nargsIxToPairIx.asString\",\"//all relations (structured and unstructured) that will become the columns of our data matrix\\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)\",\"//mapping from entity-pairs to their unique index\\nval pairToPairIx = rows.zipWithIndex.toMap\\n\\nval data = List(is_historian_at, is_professor_at, museum_at, teaches_history_at, employeeAt).map(_.map(pairToPairIx))\\n\\n//training tuples (s, ij)\\nval tuples = data.zipWithIndex.flatMap(t => t._1.map(pair => t._2 -> pair))\\n\\n//training triples (s, i, j)\\nval triples = tuples.map(t => t._1 -> tupleToArgIndices(rows(t._2))).map(t => (t._1, t._2._1, t._2._2))\\ntriples.asString\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><table class=\"matrix\">\n  <thead>\n  <tr class=\"matrixRow\">\n  <th></th>\n    <th class=\"rotate\"><div><span>'is_historian_at</span></div></th>\n    <th class=\"rotate\"><div><span>'is_professor_at</span></div></th>\n    <th class=\"rotate\"><div><span>'museum_at</span></div></th>\n    <th class=\"rotate\"><div><span>'teaches_history_at</span></div></th>\n    <th class=\"rotate\"><div><span>'employeeAt</span></div></th>\n  </tr>\n  </thead>\n  <tbody>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Petrie,'UCL</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n  </tr>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Ferguson,'Harvard</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n  </tr>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Trevelyan,'Cambridge</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n  </tr>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Andrew,'Cambridge</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n  </tr>\n  </tbody>\n</table></div>"
    }
  }, {
    "id" : 6,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//the dimension of latent representations\nval k = 2\n\n//regularization parameter\nval lambda = 0.05\n\nimplicit val random = new scala.util.Random(1l)\n\n//the domain of parameters\n@domain case class Theta(relations: IndexedSeq[Vect], pairs: IndexedSeq[Vect])\n\n//the set of possible parameters\nimplicit val Thetas = Theta.Values(Seqs(Vectors(k), cols.size), Seqs(Vectors(k), rows.size))\n\n//the class of cells\n@domain case class Cell(s: Int, i: Int, j: Int)\n\n//the set of possible cells\nimplicit val Cells = Cell.Values(Ints(0 until rows.length), Ints(0 until entities.length), Ints(0 until entities.length))\n\n//mapping cell argument indices to entity-pair index\ndef cellToPairIx(term: Cells.Term) = term.map(c => argsIxToPairIx(c.i -> c.j))\n\n//mapping training data (s, i, j) to values of the Cells domain\nval trainingData = triples.map(t => Cell(t._1, t._2, t._3)).toConst(Cells)\n\n//samples an unobserved cell for a given relation\ndef sampleNegCell(pos: Cell): Cell = {\n  def inner(attempts: Int): Cell = {\n    val row = random.nextInt(rows.size)\n    val (i,j) = tupleToArgIndices(rows(row))\n    val sample = Cell(pos.s, i, j)\n    if (attempts == 0) {\n      println(\"Couldn't sample a negative cell for \" + pos)\n      sample\n    } else if (trainingData.contains(sample)) {\n      inner(attempts - 1)\n    } else sample\n  }\n  inner(100)\n}\n\n//the score of one cell\ndef score(t: Thetas.Term)(cell: Cells.Term): DoubleTerm =\n  t.relations(cell.s) dot t.pairs(cellToPairIx(cell))\n\n//training loss \ndef loss(t: Thetas.Term) = {\n  //we sample a positive cell, and memoize the result\n  val pos = mem(trainingData.sampleShuffled)\n  //based on the memoized positive cell, we sample a negative cell      which needs to be memoized because it will reappear several times\n  val neg = mem(pos.map(sampleNegCell))\n  //regularization term\n  val l2 = sum(Seq(t.relations(pos.s), t.pairs(cellToPairIx(pos)), t.pairs(cellToPairIx(neg)))) { v => v.l2() * -lambda }\n  \n  log(sigm(score(t)(pos))) + log(sigm(-score(t)(neg))) + l2\n}\nlog(sigm(score(Thetas.Variable(\"theta\"))(Cells.Variable(\"pos\"))))",
      "extraFields" : {
        "cache" : "false",
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\nargsIxToPairIx.asString\",\"//all relations (structured and unstructured) that will become the columns of our data matrix\\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)\",\"//mapping from entity-pairs to their unique index\\nval pairToPairIx = rows.zipWithIndex.toMap\\n\\nval data = List(is_historian_at, is_professor_at, museum_at, teaches_history_at, employeeAt).map(_.map(pairToPairIx))\\n\\n//training tuples (s, ij)\\nval tuples = data.zipWithIndex.flatMap(t => t._1.map(pair => t._2 -> pair))\\n\\n//training triples (s, i, j)\\nval triples = tuples.map(t => t._1 -> tupleToArgIndices(rows(t._2))).map(t => (t._1, t._2._1, t._2._2))\\ntriples.asString\",\"//visualization of the sparse data matrix\\nMatrix((0 until rows.length).map(row => (0 until cols.length).map(col => if (data(col).contains(row)) 1.0 else 0.0).toSeq).toSeq, rows.map(t => t._1+\\\",\\\"+t._2), cols.map(_.toString))\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div id=\"termd09b7c69-c5eb-45ce-bf12-0c221ffefe0b\" class=\"term\">\n<svg width=\"960\" height=\"490\"><g transform=\"translate(120,40)\"><path class=\"link\" d=\"M376.25,200C376.25,225 376.25,225 376.25,250\"></path><path class=\"link\" d=\"M268.75,200C268.75,225 268.75,225 268.75,250\"></path><path class=\"link\" d=\"M322.5,150C322.5,175 268.75,175 268.75,200\"></path><path class=\"link\" d=\"M322.5,150C322.5,175 376.25,175 376.25,200\"></path><path class=\"link\" d=\"M161.25,200C161.25,225 161.25,225 161.25,250\"></path><path class=\"link\" d=\"M53.75,200C53.75,225 53.75,225 53.75,250\"></path><path class=\"link\" d=\"M107.5,150C107.5,175 53.75,175 53.75,200\"></path><path class=\"link\" d=\"M107.5,150C107.5,175 161.25,175 161.25,200\"></path><path class=\"link\" d=\"M215,100C215,125 107.5,125 107.5,150\"></path><path class=\"link\" d=\"M215,100C215,125 322.5,125 322.5,150\"></path><path class=\"link\" d=\"M215,50C215,75 215,75 215,100\"></path><path class=\"link\" d=\"M215,0C215,25 215,25 215,50\"></path><g class=\"node\" transform=\"translate(376.25,250)\"><circle r=\"10\"></circle><text y=\"18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">pos</text></g><g class=\"node\" transform=\"translate(376.25,200)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">$anon$1</text></g><g class=\"node\" transform=\"translate(268.75,250)\"><circle r=\"10\"></circle><text y=\"18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">theta</text></g><g class=\"node\" transform=\"translate(268.75,200)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">Field</text></g><g class=\"node\" transform=\"translate(322.5,150)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">VarSeqApply</text></g><g class=\"node\" transform=\"translate(161.25,250)\"><circle r=\"10\"></circle><text y=\"18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">pos</text></g><g class=\"node\" transform=\"translate(161.25,200)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">Field</text></g><g class=\"node\" transform=\"translate(53.75,250)\"><circle r=\"10\"></circle><text y=\"18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">theta</text></g><g class=\"node\" transform=\"translate(53.75,200)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">Field</text></g><g class=\"node\" transform=\"translate(107.5,150)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">VarSeqApply</text></g><g class=\"node\" transform=\"translate(215,100)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">DotProduct</text></g><g class=\"node\" transform=\"translate(215,50)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">Sigmoid</text></g><g class=\"node\" transform=\"translate(215,0)\"><circle r=\"10\"></circle><text y=\"-18\" dy=\".35em\" text-anchor=\"middle\" style=\"fill-opacity: 1;\">Log</text></g></g></svg>\n</div>\n<script>\n\nvar treeData = [\n\n{\n  \"name\": \"Log\",\n  \"parent\": \"null\",\n  \"children\": [\n{\n  \"name\": \"Sigmoid\",\n  \"parent\": \"Log\",\n  \"children\": [\n{\n  \"name\": \"DotProduct\",\n  \"parent\": \"Sigmoid\",\n  \"children\": [\n{\n  \"name\": \"VarSeqApply\",\n  \"parent\": \"DotProduct\",\n  \"children\": [\n{\n  \"name\": \"Field\",\n  \"parent\": \"VarSeqApply\",\n  \"children\": [\n{\n  \"name\": \"theta\",\n  \"parent\": \"Field\",\n  \"children\": []\n}\n             ]\n}\n             ,\n\n{\n  \"name\": \"Field\",\n  \"parent\": \"VarSeqApply\",\n  \"children\": [\n{\n  \"name\": \"pos\",\n  \"parent\": \"Field\",\n  \"children\": []\n}\n             ]\n}\n             ]\n}\n             ,\n\n{\n  \"name\": \"VarSeqApply\",\n  \"parent\": \"DotProduct\",\n  \"children\": [\n{\n  \"name\": \"Field\",\n  \"parent\": \"VarSeqApply\",\n  \"children\": [\n{\n  \"name\": \"theta\",\n  \"parent\": \"Field\",\n  \"children\": []\n}\n             ]\n}\n             ,\n\n{\n  \"name\": \"$anon$1\",\n  \"parent\": \"VarSeqApply\",\n  \"children\": [\n{\n  \"name\": \"pos\",\n  \"parent\": \"$anon$1\",\n  \"children\": []\n}\n             ]\n}\n             ]\n}\n             ]\n}\n             ]\n}\n             ]\n}\n\n];\n\nvar depth = 6 + 1\n\n// ************** Generate the tree diagram\t *****************\nvar margin = {top: 40, right: 120, bottom: 20, left: 120},\n\twidth = 960 - margin.right - margin.left,\n\theight = depth * 70 - margin.top - margin.bottom;\n\nvar i = 0;\n\nvar tree = d3.layout.tree()\n\t.size([height, width]);\n\nvar diagonal = d3.svg.diagonal()\n\t.projection(function(d) { return [d.x, d.y]; });\n\nvar svg = d3.select(\"#termd09b7c69-c5eb-45ce-bf12-0c221ffefe0b svg\")\n\t.attr(\"width\", width + margin.right + margin.left)\n\t.attr(\"height\", height + margin.top + margin.bottom)\n  .append(\"g\")\n\t.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\nroot = treeData[0];\n\nupdate(root);\n\nfunction update(source) {\n\n  // Compute the new tree layout.\n  var nodes = tree.nodes(source).reverse(),\n\t links = tree.links(nodes);\n\n  // Normalize for fixed-depth.\n  nodes.forEach(function(d) { d.y = d.depth * 50; });\n\n  // Declare the nodes…\n  var node = svg.selectAll(\"g.node\")\n\t  .data(nodes, function(d) { return d.id || (d.id = ++i); });\n\n  // Enter the nodes.\n  var nodeEnter = node.enter().append(\"g\")\n\t  .attr(\"class\", \"node\")\n\t  .attr(\"transform\", function(d) {\n\t\t  return \"translate(\" + d.x + \",\" + d.y + \")\"; });\n\n  nodeEnter.append(\"circle\")\n\t  .attr(\"r\", 10);\n\n  nodeEnter.append(\"text\")\n\t  .attr(\"y\", function(d) {\n\t\t  return d.children || d._children ? -18 : 18; })\n\t  .attr(\"dy\", \".35em\")\n\t  .attr(\"text-anchor\", \"middle\")\n\t  .text(function(d) { return d.name; })\n\t  .style(\"fill-opacity\", 1);\n\n  // Declare the links…\n  var link = svg.selectAll(\"path.link\")\n\t  .data(links, function(d) { return d.target.id; });\n\n  // Enter the links.\n  link.enter().insert(\"path\", \"g\")\n\t  .attr(\"class\", \"link\")\n\t  .attr(\"d\", diagonal);\n\n}\n\n</script></div>"
    }
  }, {
    "id" : 7,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : " //learning parameters\nval init = Settings(Thetas.createRandomSetting(random.nextGaussian() * 0.1))\nval adaParams = AdaGradParameters(epochs = 100, learningRate = 0.1, initParams = init, delta = 0.1)\n\n//do the training (argmax is a term, so it needs to be evaluated to do the optimization)\nval thetaStar = argmax(Thetas)(t => loss(t).argmaxBy(Argmaxer.adaGrad(adaParams))).eval()\n",
      "extraFields" : {
        "cache" : "false",
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\nargsIxToPairIx.asString\",\"//all relations (structured and unstructured) that will become the columns of our data matrix\\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)\",\"//mapping from entity-pairs to their unique index\\nval pairToPairIx = rows.zipWithIndex.toMap\\n\\nval data = List(is_historian_at, is_professor_at, museum_at, teaches_history_at, employeeAt).map(_.map(pairToPairIx))\\n\\n//training tuples (s, ij)\\nval tuples = data.zipWithIndex.flatMap(t => t._1.map(pair => t._2 -> pair))\\n\\n//training triples (s, i, j)\\nval triples = tuples.map(t => t._1 -> tupleToArgIndices(rows(t._2))).map(t => (t._1, t._2._1, t._2._2))\\ntriples.asString\",\"//visualization of the sparse data matrix\\nMatrix((0 until rows.length).map(row => (0 until cols.length).map(col => if (data(col).contains(row)) 1.0 else 0.0).toSeq).toSeq, rows.map(t => t._1+\\\",\\\"+t._2), cols.map(_.toString))\",\"//the dimension of latent representations\\nval k = 2\\n\\n//regularization parameter\\nval lambda = 0.05\\n\\nimplicit val random = new scala.util.Random(1l)\\n\\n//the domain of parameters\\n@domain case class Theta(relations: IndexedSeq[Vect], pairs: IndexedSeq[Vect])\\n\\n//the set of possible parameters\\nimplicit val Thetas = Theta.Values(Seqs(Vectors(k), cols.size), Seqs(Vectors(k), rows.size))\\n\\n//the class of cells\\n@domain case class Cell(s: Int, i: Int, j: Int)\\n\\n//the set of possible cells\\nimplicit val Cells = Cell.Values(Ints(0 until rows.length), Ints(0 until entities.length), Ints(0 until entities.length))\\n\\n//mapping cell argument indices to entity-pair index\\ndef cellToPairIx(term: Cells.Term) = term.map(c => argsIxToPairIx(c.i -> c.j))\\n\\n//mapping training data (s, i, j) to values of the Cells domain\\nval trainingData = triples.map(t => Cell(t._1, t._2, t._3)).toConst(Cells)\\n\\n//samples an unobserved cell for a given relation\\ndef sampleNegCell(pos: Cell): Cell = {\\n  def inner(attempts: Int): Cell = {\\n    val row = random.nextInt(rows.size)\\n    val (i,j) = tupleToArgIndices(rows(row))\\n    val sample = Cell(pos.s, i, j)\\n    if (attempts == 0) {\\n      println(\\\"Couldn't sample a negative cell for \\\" + pos)\\n      sample\\n    } else if (trainingData.contains(sample)) {\\n      inner(attempts - 1)\\n    } else sample\\n  }\\n  inner(100)\\n}\\n\\n//the score of one cell\\ndef score(t: Thetas.Term)(cell: Cells.Term): DoubleTerm =\\n  t.relations(cell.s) dot t.pairs(cellToPairIx(cell))\\n\\n//training loss \\ndef loss(t: Thetas.Term) = {\\n  //we sample a positive cell, and memoize the result\\n  val pos = mem(trainingData.sampleShuffled)\\n  //based on the memoized positive cell, we sample a negative cell      which needs to be memoized because it will reappear several times\\n  val neg = mem(pos.map(sampleNegCell))\\n  //regularization term\\n  val l2 = sum(Seq(t.relations(pos.s), t.pairs(cellToPairIx(pos)), t.pairs(cellToPairIx(neg)))) { v => v.l2() * -lambda }\\n  \\n  log(sigm(score(t)(pos))) + log(sigm(-score(t)(neg))) + l2\\n}\\nlog(sigm(score(Thetas.Variable(\\\"theta\\\"))(Cells.Variable(\\\"pos\\\"))))\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div class=\"asProduct Theta\"><span class=\"typeName\">Theta</span>\n<ul class=\"fields\">\n  <li class=\"field\"><span class=\"fieldName\">relations</span> <span class=\"fieldValue\"><div class=\"asIterable Vector\"><span class=\"typeName\">Vector</span>\n    <ol start=\"0\" class=\"fields\">\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(0.7738624893441116,0.37009847150420744)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(-0.4356626724603654,-0.25512682215793214)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(-0.7813749883843562,-1.1501266496558864)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(-0.8741315964429471,0.23209205456145787)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(-0.7441157183719632,-1.0464510057036926)</span></li>\n    </ol>\n</div></span></li>\n  <li class=\"field\"><span class=\"fieldName\">pairs</span> <span class=\"fieldValue\"><div class=\"asIterable Vector\"><span class=\"typeName\">Vector</span>\n    <ol start=\"0\" class=\"fields\">\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(-0.5322266915807075,-0.6840621259286139)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(0.439845552214823,0.30289397792513467)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(0.7903604352649711,0.5851578770664773)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(-0.4025207667056727,0.3627513991480795)</span></li>\n    </ol>\n</div></span></li>\n</ul>\n</div></div>"
    }
  }, {
    "id" : 8,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val thetaLearned: Thetas.Term = Thetas.Const(thetaStar)\n\nval probFun = fun(Cells) { x => sigm(score(thetaLearned)(x)) }\n\ndef predict(s: Int, i: Int, j: Int): Double = probFun(Cell(s, i, j))\n\ndef predict(s: Int, ij: Int): Double = {\n    val (i,j) = tupleToArgIndices(rows(ij))\n    predict(s, i, j)\n}\n\nMatrix((0 until rows.length).map(row => (0 until cols.length).map(col => predict(col,row)).toSeq).toSeq, rows.map(t => t._1+\",\"+t._2), cols.map(_.toString))",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\nargsIxToPairIx.asString\",\"//all relations (structured and unstructured) that will become the columns of our data matrix\\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)\",\"//mapping from entity-pairs to their unique index\\nval pairToPairIx = rows.zipWithIndex.toMap\\n\\nval data = List(is_historian_at, is_professor_at, museum_at, teaches_history_at, employeeAt).map(_.map(pairToPairIx))\\n\\n//training tuples (s, ij)\\nval tuples = data.zipWithIndex.flatMap(t => t._1.map(pair => t._2 -> pair))\\n\\n//training triples (s, i, j)\\nval triples = tuples.map(t => t._1 -> tupleToArgIndices(rows(t._2))).map(t => (t._1, t._2._1, t._2._2))\\ntriples.asString\",\"//visualization of the sparse data matrix\\nMatrix((0 until rows.length).map(row => (0 until cols.length).map(col => if (data(col).contains(row)) 1.0 else 0.0).toSeq).toSeq, rows.map(t => t._1+\\\",\\\"+t._2), cols.map(_.toString))\",\"//the dimension of latent representations\\nval k = 2\\n\\n//regularization parameter\\nval lambda = 0.05\\n\\nimplicit val random = new scala.util.Random(1l)\\n\\n//the domain of parameters\\n@domain case class Theta(relations: IndexedSeq[Vect], pairs: IndexedSeq[Vect])\\n\\n//the set of possible parameters\\nimplicit val Thetas = Theta.Values(Seqs(Vectors(k), cols.size), Seqs(Vectors(k), rows.size))\\n\\n//the class of cells\\n@domain case class Cell(s: Int, i: Int, j: Int)\\n\\n//the set of possible cells\\nimplicit val Cells = Cell.Values(Ints(0 until rows.length), Ints(0 until entities.length), Ints(0 until entities.length))\\n\\n//mapping cell argument indices to entity-pair index\\ndef cellToPairIx(term: Cells.Term) = term.map(c => argsIxToPairIx(c.i -> c.j))\\n\\n//mapping training data (s, i, j) to values of the Cells domain\\nval trainingData = triples.map(t => Cell(t._1, t._2, t._3)).toConst(Cells)\\n\\n//samples an unobserved cell for a given relation\\ndef sampleNegCell(pos: Cell): Cell = {\\n  def inner(attempts: Int): Cell = {\\n    val row = random.nextInt(rows.size)\\n    val (i,j) = tupleToArgIndices(rows(row))\\n    val sample = Cell(pos.s, i, j)\\n    if (attempts == 0) {\\n      println(\\\"Couldn't sample a negative cell for \\\" + pos)\\n      sample\\n    } else if (trainingData.contains(sample)) {\\n      inner(attempts - 1)\\n    } else sample\\n  }\\n  inner(100)\\n}\\n\\n//the score of one cell\\ndef score(t: Thetas.Term)(cell: Cells.Term): DoubleTerm =\\n  t.relations(cell.s) dot t.pairs(cellToPairIx(cell))\\n\\n//training loss \\ndef loss(t: Thetas.Term) = {\\n  //we sample a positive cell, and memoize the result\\n  val pos = mem(trainingData.sampleShuffled)\\n  //based on the memoized positive cell, we sample a negative cell      which needs to be memoized because it will reappear several times\\n  val neg = mem(pos.map(sampleNegCell))\\n  //regularization term\\n  val l2 = sum(Seq(t.relations(pos.s), t.pairs(cellToPairIx(pos)), t.pairs(cellToPairIx(neg)))) { v => v.l2() * -lambda }\\n  \\n  log(sigm(score(t)(pos))) + log(sigm(-score(t)(neg))) + l2\\n}\\nlog(sigm(score(Thetas.Variable(\\\"theta\\\"))(Cells.Variable(\\\"pos\\\"))))\",\" //learning parameters\\nval init = Settings(Thetas.createRandomSetting(random.nextGaussian() * 0.1))\\nval adaParams = AdaGradParameters(epochs = 100, learningRate = 0.1, initParams = init, delta = 0.1)\\n\\n//do the training (argmax is a term, so it needs to be evaluated to do the optimization)\\nval thetaStar = argmax(Thetas)(t => loss(t).argmaxBy(Argmaxer.adaGrad(adaParams))).eval()\\n\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><table class=\"matrix\">\n  <thead>\n  <tr class=\"matrixRow\">\n  <th></th>\n    <th class=\"rotate\"><div><span>'is_historian_at</span></div></th>\n    <th class=\"rotate\"><div><span>'is_professor_at</span></div></th>\n    <th class=\"rotate\"><div><span>'museum_at</span></div></th>\n    <th class=\"rotate\"><div><span>'teaches_history_at</span></div></th>\n    <th class=\"rotate\"><div><span>'employeeAt</span></div></th>\n  </tr>\n  </thead>\n  <tbody>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Petrie,'UCL</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:0.223869\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.694942\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.651201\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.970152\"></td>\n  </tr>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Ferguson,'Harvard</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:0.714836\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.392999\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.212967\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.372966\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.232321\"></td>\n  </tr>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Trevelyan,'Cambridge</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:0.868016\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.295146\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.269204\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.028266\"></td>\n  </tr>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Andrew,'Cambridge</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:0.433901\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.551187\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.467421\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.707765\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.477617\"></td>\n  </tr>\n  </tbody>\n</table></div>"
    }
  }, {
    "id" : 9,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val entityPairEmbeddings = rows.zipWithIndex.map(t => (0, t._1.toString, thetaStar.pairs(t._2).asInstanceOf[Vect].asArray.toSeq)).toSeq\n\nval relationEmbeddings = cols.zipWithIndex.map(t => (1, t._1.toString, thetaStar.relations(t._2).asArray.toSeq)).toSeq\n\n//visualization of embeddings\nCustom.Vectors(entityPairEmbeddings ++ relationEmbeddings).norm",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\nargsIxToPairIx.asString\",\"//all relations (structured and unstructured) that will become the columns of our data matrix\\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)\",\"//mapping from entity-pairs to their unique index\\nval pairToPairIx = rows.zipWithIndex.toMap\\n\\nval data = List(is_historian_at, is_professor_at, museum_at, teaches_history_at, employeeAt).map(_.map(pairToPairIx))\\n\\n//training tuples (s, ij)\\nval tuples = data.zipWithIndex.flatMap(t => t._1.map(pair => t._2 -> pair))\\n\\n//training triples (s, i, j)\\nval triples = tuples.map(t => t._1 -> tupleToArgIndices(rows(t._2))).map(t => (t._1, t._2._1, t._2._2))\\ntriples.asString\",\"//visualization of the sparse data matrix\\nMatrix((0 until rows.length).map(row => (0 until cols.length).map(col => if (data(col).contains(row)) 1.0 else 0.0).toSeq).toSeq, rows.map(t => t._1+\\\",\\\"+t._2), cols.map(_.toString))\",\"//the dimension of latent representations\\nval k = 2\\n\\n//regularization parameter\\nval lambda = 0.05\\n\\nimplicit val random = new scala.util.Random(1l)\\n\\n//the domain of parameters\\n@domain case class Theta(relations: IndexedSeq[Vect], pairs: IndexedSeq[Vect])\\n\\n//the set of possible parameters\\nimplicit val Thetas = Theta.Values(Seqs(Vectors(k), cols.size), Seqs(Vectors(k), rows.size))\\n\\n//the class of cells\\n@domain case class Cell(s: Int, i: Int, j: Int)\\n\\n//the set of possible cells\\nimplicit val Cells = Cell.Values(Ints(0 until rows.length), Ints(0 until entities.length), Ints(0 until entities.length))\\n\\n//mapping cell argument indices to entity-pair index\\ndef cellToPairIx(term: Cells.Term) = term.map(c => argsIxToPairIx(c.i -> c.j))\\n\\n//mapping training data (s, i, j) to values of the Cells domain\\nval trainingData = triples.map(t => Cell(t._1, t._2, t._3)).toConst(Cells)\\n\\n//samples an unobserved cell for a given relation\\ndef sampleNegCell(pos: Cell): Cell = {\\n  def inner(attempts: Int): Cell = {\\n    val row = random.nextInt(rows.size)\\n    val (i,j) = tupleToArgIndices(rows(row))\\n    val sample = Cell(pos.s, i, j)\\n    if (attempts == 0) {\\n      println(\\\"Couldn't sample a negative cell for \\\" + pos)\\n      sample\\n    } else if (trainingData.contains(sample)) {\\n      inner(attempts - 1)\\n    } else sample\\n  }\\n  inner(100)\\n}\\n\\n//the score of one cell\\ndef score(t: Thetas.Term)(cell: Cells.Term): DoubleTerm =\\n  t.relations(cell.s) dot t.pairs(cellToPairIx(cell))\\n\\n//training loss \\ndef loss(t: Thetas.Term) = {\\n  //we sample a positive cell, and memoize the result\\n  val pos = mem(trainingData.sampleShuffled)\\n  //based on the memoized positive cell, we sample a negative cell      which needs to be memoized because it will reappear several times\\n  val neg = mem(pos.map(sampleNegCell))\\n  //regularization term\\n  val l2 = sum(Seq(t.relations(pos.s), t.pairs(cellToPairIx(pos)), t.pairs(cellToPairIx(neg)))) { v => v.l2() * -lambda }\\n  \\n  log(sigm(score(t)(pos))) + log(sigm(-score(t)(neg))) + l2\\n}\\nlog(sigm(score(Thetas.Variable(\\\"theta\\\"))(Cells.Variable(\\\"pos\\\"))))\",\" //learning parameters\\nval init = Settings(Thetas.createRandomSetting(random.nextGaussian() * 0.1))\\nval adaParams = AdaGradParameters(epochs = 100, learningRate = 0.1, initParams = init, delta = 0.1)\\n\\n//do the training (argmax is a term, so it needs to be evaluated to do the optimization)\\nval thetaStar = argmax(Thetas)(t => loss(t).argmaxBy(Argmaxer.adaGrad(adaParams))).eval()\\n\",\"val thetaLearned: Thetas.Term = Thetas.Const(thetaStar)\\n\\nval probFun = fun(Cells) { x => sigm(score(thetaLearned)(x)) }\\n\\ndef predict(s: Int, i: Int, j: Int): Double = probFun(Cell(s, i, j))\\n\\ndef predict(s: Int, ij: Int): Double = {\\n    val (i,j) = tupleToArgIndices(rows(ij))\\n    predict(s, i, j)\\n}\\n\\nMatrix((0 until rows.length).map(row => (0 until cols.length).map(col => predict(col,row)).toSeq).toSeq, rows.map(t => t._1+\\\",\\\"+t._2), cols.map(_.toString))\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div id=\"vectorsDivc7055962-5306-419f-ba13-6264da6b4410\"><svg width=\"600\" height=\"450\"><g transform=\"translate(0,0)\"><rect width=\"600\" height=\"450\" style=\"fill: none; pointer-events: all;\"></rect><g><g class=\"nodes\"><g class=\"node\"><circle r=\"5\" cx=\"152.70547961452678\" cy=\"144.00336417028637\" fill=\"#1f77b4\" class=\"nodeGroup0\"><title>\"('Petrie,'UCL)\"</title></circle><text x=\"152.70547961452678\" y=\"144.00336417028637\" class=\"nodeGroup0\" font-family=\"Bree Serif\" font-size=\"1em\">\"('Petrie,'UCL)\"</text></g><g class=\"node\"><circle r=\"5\" cx=\"444.7081522852085\" cy=\"343.06849212441796\" fill=\"#1f77b4\" class=\"nodeGroup0\"><title>\"('Ferguson,'Harvard)\"</title></circle><text x=\"444.7081522852085\" y=\"343.06849212441796\" class=\"nodeGroup0\" font-family=\"Bree Serif\" font-size=\"1em\">\"('Ferguson,'Harvard)\"</text></g><g class=\"node\"><circle r=\"5\" cx=\"550\" cy=\"400\" fill=\"#1f77b4\" class=\"nodeGroup0\"><title>\"('Trevelyan,'Cambridge)\"</title></circle><text x=\"550\" y=\"400\" class=\"nodeGroup0\" font-family=\"Bree Serif\" font-size=\"1em\">\"('Trevelyan,'Cambridge)\"</text></g><g class=\"node\"><circle r=\"5\" cx=\"191.66809475601977\" cy=\"355.14149635249214\" fill=\"#1f77b4\" class=\"nodeGroup0\"><title>\"('Andrew,'Cambridge)\"</title></circle><text x=\"191.66809475601977\" y=\"355.14149635249214\" class=\"nodeGroup0\" font-family=\"Bree Serif\" font-size=\"1em\">\"('Andrew,'Cambridge)\"</text></g><g class=\"node\"><circle r=\"5\" cx=\"545.0441499248479\" cy=\"356.6233716790138\" fill=\"#ff7f0e\" class=\"nodeGroup1\"><title>\"'is_historian_at\"</title></circle><text x=\"545.0441499248479\" y=\"356.6233716790138\" class=\"nodeGroup1\" font-family=\"Bree Serif\" font-size=\"1em\">\"'is_historian_at\"</text></g><g class=\"node\"><circle r=\"5\" cx=\"181.71253320229874\" cy=\"230.5179120774828\" fill=\"#ff7f0e\" class=\"nodeGroup1\"><title>\"'is_professor_at\"</title></circle><text x=\"181.71253320229874\" y=\"230.5179120774828\" class=\"nodeGroup1\" font-family=\"Bree Serif\" font-size=\"1em\">\"'is_professor_at\"</text></g><g class=\"node\"><circle r=\"5\" cx=\"77.86333797086863\" cy=\"50\" fill=\"#ff7f0e\" class=\"nodeGroup1\"><title>\"'museum_at\"</title></circle><text x=\"77.86333797086863\" y=\"50\" class=\"nodeGroup1\" font-family=\"Bree Serif\" font-size=\"1em\">\"'museum_at\"</text></g><g class=\"node\"><circle r=\"5\" cx=\"50\" cy=\"328.7880252639815\" fill=\"#ff7f0e\" class=\"nodeGroup1\"><title>\"'teaches_history_at\"</title></circle><text x=\"50\" y=\"328.7880252639815\" class=\"nodeGroup1\" font-family=\"Bree Serif\" font-size=\"1em\">\"'teaches_history_at\"</text></g><g class=\"node\"><circle r=\"5\" cx=\"89.05572258509882\" cy=\"70.91096579522112\" fill=\"#ff7f0e\" class=\"nodeGroup1\"><title>\"'employeeAt\"</title></circle><text x=\"89.05572258509882\" y=\"70.91096579522112\" class=\"nodeGroup1\" font-family=\"Bree Serif\" font-size=\"1em\">\"'employeeAt\"</text></g></g></g></g></svg></div>\n\n<script type=\"text/javascript\">\n drawVectors([{\"_1\":0,\"_2\":\"('Petrie,'UCL)\",\"_3\":[0.20541095922905356,0.2685810404865325]},{\"_1\":0,\"_2\":\"('Ferguson,'Harvard)\",\"_3\":[0.789416304570417,0.8373385489269085]},{\"_1\":0,\"_2\":\"('Trevelyan,'Cambridge)\",\"_3\":[1.0,1.0]},{\"_1\":0,\"_2\":\"('Andrew,'Cambridge)\",\"_3\":[0.28333618951203954,0.871832846721406]},{\"_1\":1,\"_2\":\"'is_historian_at\",\"_3\":[0.9900882998496958,0.8760667762257538]},{\"_1\":1,\"_2\":\"'is_professor_at\",\"_3\":[0.2634250664045975,0.5157654630785223]},{\"_1\":1,\"_2\":\"'museum_at\",\"_3\":[0.05572667594173724,0.0]},{\"_1\":1,\"_2\":\"'teaches_history_at\",\"_3\":[0.0,0.7965372150399472]},{\"_1\":1,\"_2\":\"'employeeAt\",\"_3\":[0.07811144517019764,0.059745616557774626]}], \"vectorsDivc7055962-5306-419f-ba13-6264da6b4410\");\n</script></div>"
    }
  } ],
  "config" : { }
}
