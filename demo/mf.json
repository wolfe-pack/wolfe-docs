{
  "name" : "Relation Extraction with Matrix Factorization",
  "cells" : [ {
    "id" : 0,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//all entities\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\n\n//a Freebase relation\ndef employeeAt = Set('Petrie -> 'UCL)\n\n//visualization of knowledge graph\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))",
      "extraFields" : {
        "aggregatedCells" : "[]"
      },
      "outputFormat" : "<div class=\"string-result\"><div id=\"graphDiv1a7e1e41-6713-4365-ac65-35754fcbc74d\"><svg width=\"750\" height=\"450\"><g><rect width=\"750\" height=\"450\" style=\"opacity: 0;\"></rect><line class=\"link\" opacity=\"1\" style=\"stroke-width: 3.16227766016838px; stroke: rgb(136, 136, 136);\" x1=\"512.3641005634088\" y1=\"131.96378720577067\" x2=\"419.2765211523351\" y2=\"72.76193412385162\"><title>\"\"</title></line><g class=\"node\" transform=\"translate(243.05053315316414,101.79918427309093)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Cambridge\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Cambridge</text></g><g class=\"node\" transform=\"translate(512.3641005634088,131.96378720577067)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'UCL\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'UCL</text></g><g class=\"node\" transform=\"translate(390.2769103432616,261.8465999071419)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Harvard\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Harvard</text></g><g class=\"node\" transform=\"translate(419.2765211523351,72.76193412385162)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Petrie\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Petrie</text></g><g class=\"node\" transform=\"translate(317.3477059005324,403.27897201614564)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Ferguson\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Ferguson</text></g><g class=\"node\" transform=\"translate(210.7203417168619,256.1256245500333)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Andrew\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Andrew</text></g><g class=\"node\" transform=\"translate(526.4728134081649,347.2289719768267)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Trevelyan\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Trevelyan</text></g></g></svg></div>\n\n<script type=\"text/javascript\">\n drawGraph({\"nodes\":[{\"name\":\"'Cambridge\",\"description\":\"'Cambridge\",\"value\":1.0,\"group\":0},{\"name\":\"'UCL\",\"description\":\"'UCL\",\"value\":1.0,\"group\":0},{\"name\":\"'Harvard\",\"description\":\"'Harvard\",\"value\":1.0,\"group\":0},{\"name\":\"'Petrie\",\"description\":\"'Petrie\",\"value\":1.0,\"group\":0},{\"name\":\"'Ferguson\",\"description\":\"'Ferguson\",\"value\":1.0,\"group\":0},{\"name\":\"'Andrew\",\"description\":\"'Andrew\",\"value\":1.0,\"group\":0},{\"name\":\"'Trevelyan\",\"description\":\"'Trevelyan\",\"value\":1.0,\"group\":0}],\"edges\":[{\"source\":1,\"target\":3,\"description\":\"\",\"value\":1.0,\"group\":0}],\"directed\":\"false\"}, \"graphDiv1a7e1e41-6713-4365-ac65-35754fcbc74d\");\n</script></div>"
    }
  }, {
    "id" : 1,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//some surface form relations\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\ndef museum_at = Set('Petrie -> 'UCL)\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\n\n//visualization of knowledge graph and surface forms\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div id=\"graphDivefbe852b-86ad-4a23-8170-d0fcc9c22cc5\"><svg width=\"750\" height=\"450\"><g><rect width=\"750\" height=\"450\" style=\"opacity: 0;\"></rect><line class=\"link\" opacity=\"1\" style=\"stroke-width: 3.16227766016838px; stroke: rgb(136, 136, 136);\" x1=\"478.992068472611\" y1=\"110.3325144196836\" x2=\"530.4620405926291\" y2=\"206.2618874137928\"><title>\"\"</title></line><line class=\"link\" opacity=\"1\" style=\"stroke-width: 3.16227766016838px; stroke: rgb(136, 136, 136);\" x1=\"478.992068472611\" y1=\"110.3325144196836\" x2=\"377.6010794053734\" y2=\"70.96756456197672\"><title>\"\"</title></line><line class=\"link\" opacity=\"1\" style=\"stroke-width: 3.16227766016838px; stroke: rgb(136, 136, 136);\" x1=\"455.8609448919987\" y1=\"370.62777083956877\" x2=\"347.8421913757891\" y2=\"389.7665667127767\"><title>\"\"</title></line><line class=\"link\" opacity=\"1\" style=\"stroke-width: 3.16227766016838px; stroke: rgb(136, 136, 136);\" x1=\"241.8068299825561\" y1=\"253.3029100228236\" x2=\"208.04184010214647\" y2=\"150.341753537391\"><title>\"\"</title></line><g class=\"node\" transform=\"translate(478.992068472611,110.3325144196836)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Cambridge\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Cambridge</text></g><g class=\"node\" transform=\"translate(455.8609448919987,370.62777083956877)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'UCL\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'UCL</text></g><g class=\"node\" transform=\"translate(241.8068299825561,253.3029100228236)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Harvard\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Harvard</text></g><g class=\"node\" transform=\"translate(347.8421913757891,389.7665667127767)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Petrie\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Petrie</text></g><g class=\"node\" transform=\"translate(208.04184010214647,150.341753537391)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Ferguson\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Ferguson</text></g><g class=\"node\" transform=\"translate(530.4620405926291,206.2618874137928)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Andrew\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Andrew</text></g><g class=\"node\" transform=\"translate(377.6010794053734,70.96756456197672)\"><circle r=\"10\" fill=\"#1f77b4\" opacity=\"1\" class=\"nodeGroup0\"><title>\"'Trevelyan\"</title></circle><text x=\"15\" y=\"15\" font-family=\"Bree Serif\" font-size=\"1em\" text-anchor=\"beginning\" class=\"nodeLabel\">'Trevelyan</text></g></g></svg></div>\n\n<script type=\"text/javascript\">\n drawGraph({\"nodes\":[{\"name\":\"'Cambridge\",\"description\":\"'Cambridge\",\"value\":1.0,\"group\":0},{\"name\":\"'UCL\",\"description\":\"'UCL\",\"value\":1.0,\"group\":0},{\"name\":\"'Harvard\",\"description\":\"'Harvard\",\"value\":1.0,\"group\":0},{\"name\":\"'Petrie\",\"description\":\"'Petrie\",\"value\":1.0,\"group\":0},{\"name\":\"'Ferguson\",\"description\":\"'Ferguson\",\"value\":1.0,\"group\":0},{\"name\":\"'Andrew\",\"description\":\"'Andrew\",\"value\":1.0,\"group\":0},{\"name\":\"'Trevelyan\",\"description\":\"'Trevelyan\",\"value\":1.0,\"group\":0}],\"edges\":[{\"source\":0,\"target\":5,\"description\":\"\",\"value\":1.0,\"group\":0},{\"source\":0,\"target\":6,\"description\":\"\",\"value\":1.0,\"group\":0},{\"source\":1,\"target\":3,\"description\":\"\",\"value\":1.0,\"group\":0},{\"source\":2,\"target\":4,\"description\":\"\",\"value\":1.0,\"group\":0}],\"directed\":\"false\"}, \"graphDivefbe852b-86ad-4a23-8170-d0fcc9c22cc5\");\n</script></div>"
    }
  }, {
    "id" : 2,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//all entity-pairs that will become the rows of our data matrix\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\n\n//convenience data structures\n//mapping from entities that appear as first arguments to their index\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\n\n//mapping from entities that appear as second arguments to their index\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\n\n//mapping from tuples to their argument indices\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\n\n//mapping from argument indices to entity-pair index\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\n",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div class=\"asMap Map\"><span class=\"typeName\">Map</span>\n<ul class=\"fields\">\n  <li class=\"field\"><span class=\"fieldName\"><div class=\"asProduct Tuple2\"><span class=\"typeName\">Tuple2</span>\n    <ul class=\"fields\">\n      <li class=\"field\"><span class=\"fieldName\">_1</span> <span class=\"fieldValue\"><span class=\"asString String\">0</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_2</span> <span class=\"fieldValue\"><span class=\"asString String\">0</span></span></li>\n    </ul>\n</div></span> <span class=\"fieldValue\"><span class=\"asString String\">0</span></span></li>\n  <li class=\"field\"><span class=\"fieldName\"><div class=\"asProduct Tuple2\"><span class=\"typeName\">Tuple2</span>\n    <ul class=\"fields\">\n      <li class=\"field\"><span class=\"fieldName\">_1</span> <span class=\"fieldValue\"><span class=\"asString String\">1</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_2</span> <span class=\"fieldValue\"><span class=\"asString String\">1</span></span></li>\n    </ul>\n</div></span> <span class=\"fieldValue\"><span class=\"asString String\">1</span></span></li>\n  <li class=\"field\"><span class=\"fieldName\"><div class=\"asProduct Tuple2\"><span class=\"typeName\">Tuple2</span>\n    <ul class=\"fields\">\n      <li class=\"field\"><span class=\"fieldName\">_1</span> <span class=\"fieldValue\"><span class=\"asString String\">2</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_2</span> <span class=\"fieldValue\"><span class=\"asString String\">2</span></span></li>\n    </ul>\n</div></span> <span class=\"fieldValue\"><span class=\"asString String\">2</span></span></li>\n  <li class=\"field\"><span class=\"fieldName\"><div class=\"asProduct Tuple2\"><span class=\"typeName\">Tuple2</span>\n    <ul class=\"fields\">\n      <li class=\"field\"><span class=\"fieldName\">_1</span> <span class=\"fieldValue\"><span class=\"asString String\">3</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_2</span> <span class=\"fieldValue\"><span class=\"asString String\">2</span></span></li>\n    </ul>\n</div></span> <span class=\"fieldValue\"><span class=\"asString String\">3</span></span></li>\n</ul>\n</div></div>"
    }
  }, {
    "id" : 3,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//all relations (structured and unstructured) that will become the columns of our data matrix\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\n\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div class=\"asIterable List\"><span class=\"typeName\">List</span>\n<ol start=\"0\" class=\"fields\">\n  <li class=\"fieldValue\"><span class=\"asString String\">'is_historian_at</span></li>\n  <li class=\"fieldValue\"><span class=\"asString String\">'is_professor_at</span></li>\n  <li class=\"fieldValue\"><span class=\"asString String\">'museum_at</span></li>\n  <li class=\"fieldValue\"><span class=\"asString String\">'teaches_history_at</span></li>\n  <li class=\"fieldValue\"><span class=\"asString String\">'employeeAt</span></li>\n</ol>\n</div></div>"
    }
  }, {
    "id" : 4,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//mapping from entity-pairs to their unique index\nval pairToPairIx = rows.zipWithIndex.toMap\n\nval data = List(is_historian_at, is_professor_at, museum_at, teaches_history_at, employeeAt).map(_.map(pairToPairIx))\n\n//training tuples (s, ij)\nval tuples = data.zipWithIndex.flatMap(t => t._1.map(pair => t._2 -> pair))\n\n//training triples (s, i, j)\nval triples = tuples.map(t => t._1 -> tupleToArgIndices(rows(t._2))).map(t => (t._1, t._2._1, t._2._2))",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\n\",\"//all relations (structured and unstructured) that will become the columns of our data matrix\\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div class=\"asIterable List\"><span class=\"typeName\">List</span>\n<ol start=\"0\" class=\"fields\">\n  <li class=\"fieldValue\"><div class=\"asProduct Tuple3\"><span class=\"typeName\">Tuple3</span>\n    <ul class=\"fields\">\n      <li class=\"field\"><span class=\"fieldName\">_1</span> <span class=\"fieldValue\"><span class=\"asString String\">0</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_2</span> <span class=\"fieldValue\"><span class=\"asString String\">1</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_3</span> <span class=\"fieldValue\"><span class=\"asString String\">1</span></span></li>\n    </ul>\n</div></li>\n  <li class=\"fieldValue\"><div class=\"asProduct Tuple3\"><span class=\"typeName\">Tuple3</span>\n    <ul class=\"fields\">\n      <li class=\"field\"><span class=\"fieldName\">_1</span> <span class=\"fieldValue\"><span class=\"asString String\">0</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_2</span> <span class=\"fieldValue\"><span class=\"asString String\">2</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_3</span> <span class=\"fieldValue\"><span class=\"asString String\">2</span></span></li>\n    </ul>\n</div></li>\n  <li class=\"fieldValue\"><div class=\"asProduct Tuple3\"><span class=\"typeName\">Tuple3</span>\n    <ul class=\"fields\">\n      <li class=\"field\"><span class=\"fieldName\">_1</span> <span class=\"fieldValue\"><span class=\"asString String\">1</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_2</span> <span class=\"fieldValue\"><span class=\"asString String\">0</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_3</span> <span class=\"fieldValue\"><span class=\"asString String\">0</span></span></li>\n    </ul>\n</div></li>\n  <li class=\"fieldValue\"><div class=\"asProduct Tuple3\"><span class=\"typeName\">Tuple3</span>\n    <ul class=\"fields\">\n      <li class=\"field\"><span class=\"fieldName\">_1</span> <span class=\"fieldValue\"><span class=\"asString String\">1</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_2</span> <span class=\"fieldValue\"><span class=\"asString String\">1</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_3</span> <span class=\"fieldValue\"><span class=\"asString String\">1</span></span></li>\n    </ul>\n</div></li>\n  <li class=\"fieldValue\"><div class=\"asProduct Tuple3\"><span class=\"typeName\">Tuple3</span>\n    <ul class=\"fields\">\n      <li class=\"field\"><span class=\"fieldName\">_1</span> <span class=\"fieldValue\"><span class=\"asString String\">1</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_2</span> <span class=\"fieldValue\"><span class=\"asString String\">3</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_3</span> <span class=\"fieldValue\"><span class=\"asString String\">2</span></span></li>\n    </ul>\n</div></li>\n  <li class=\"fieldValue\"><div class=\"asProduct Tuple3\"><span class=\"typeName\">Tuple3</span>\n    <ul class=\"fields\">\n      <li class=\"field\"><span class=\"fieldName\">_1</span> <span class=\"fieldValue\"><span class=\"asString String\">2</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_2</span> <span class=\"fieldValue\"><span class=\"asString String\">0</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_3</span> <span class=\"fieldValue\"><span class=\"asString String\">0</span></span></li>\n    </ul>\n</div></li>\n  <li class=\"fieldValue\"><div class=\"asProduct Tuple3\"><span class=\"typeName\">Tuple3</span>\n    <ul class=\"fields\">\n      <li class=\"field\"><span class=\"fieldName\">_1</span> <span class=\"fieldValue\"><span class=\"asString String\">3</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_2</span> <span class=\"fieldValue\"><span class=\"asString String\">3</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_3</span> <span class=\"fieldValue\"><span class=\"asString String\">2</span></span></li>\n    </ul>\n</div></li>\n  <li class=\"fieldValue\"><div class=\"asProduct Tuple3\"><span class=\"typeName\">Tuple3</span>\n    <ul class=\"fields\">\n      <li class=\"field\"><span class=\"fieldName\">_1</span> <span class=\"fieldValue\"><span class=\"asString String\">4</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_2</span> <span class=\"fieldValue\"><span class=\"asString String\">0</span></span></li>\n      <li class=\"field\"><span class=\"fieldName\">_3</span> <span class=\"fieldValue\"><span class=\"asString String\">0</span></span></li>\n    </ul>\n</div></li>\n</ol>\n</div></div>"
    }
  }, {
    "id" : 5,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//visualization of the sparse data matrix\nMatrix((0 until rows.length).map(row => (0 until cols.length).map(col => if (data(col).contains(row)) 1.0 else 0.0).toSeq).toSeq, rows.map(t => t._1+\",\"+t._2), cols.map(_.toString))",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\n\",\"//all relations (structured and unstructured) that will become the columns of our data matrix\\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)\",\"//mapping from entity-pairs to their unique index\\nval pairToPairIx = rows.zipWithIndex.toMap\\n\\nval data = List(is_historian_at, is_professor_at, museum_at, teaches_history_at, employeeAt).map(_.map(pairToPairIx))\\n\\n//training tuples (s, ij)\\nval tuples = data.zipWithIndex.flatMap(t => t._1.map(pair => t._2 -> pair))\\n\\n//training triples (s, i, j)\\nval triples = tuples.map(t => t._1 -> tupleToArgIndices(rows(t._2))).map(t => (t._1, t._2._1, t._2._2))\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><table class=\"matrix\">\n  <thead>\n  <tr class=\"matrixRow\">\n  <th></th>\n    <th class=\"rotate\"><div><span>'is_historian_at</span></div></th>\n    <th class=\"rotate\"><div><span>'is_professor_at</span></div></th>\n    <th class=\"rotate\"><div><span>'museum_at</span></div></th>\n    <th class=\"rotate\"><div><span>'teaches_history_at</span></div></th>\n    <th class=\"rotate\"><div><span>'employeeAt</span></div></th>\n  </tr>\n  </thead>\n  <tbody>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Petrie,'UCL</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n  </tr>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Ferguson,'Harvard</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n  </tr>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Trevelyan,'Cambridge</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n  </tr>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Andrew,'Cambridge</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n  </tr>\n  </tbody>\n</table></div>"
    }
  }, {
    "id" : 6,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "//the dimension of latent representations\nval k = 10\n\nimplicit val random = new scala.util.Random(1l)\n\n//the domain of parameters\n@domain case class Theta(relations: IndexedSeq[Vect], pairs: IndexedSeq[Vect])\n\n//the set of possible parameters\nimplicit val Thetas = Theta.Values(Seqs(Vectors(k), cols.size), Seqs(Vectors(k), rows.size))\n\n//the class of cells\n@domain case class Cell(s: Int, i: Int, j: Int)\n\n//the set of possible cells\nimplicit val Cells = Cell.Values(Ints(0 until rows.length), Ints(0 until entities.length), Ints(0 until entities.length))\n\n//mapping cell argument indices to entity-pair index\ndef cellToPairIx(term: Cells.Term) = term.map(c => argsIxToPairIx(c.i -> c.j))\n\n//mapping training data (s, i, j) to values of the Cells domain\nval trainingData = triples.map(t => Cell(t._1, t._2, t._3)).toConst(Cells)\n\n//samples an unobserved cell for a given relation\ndef sampleNegCell(pos: Cell): Cell = {\n  def inner(attempts: Int): Cell = {\n    val row = random.nextInt(rows.size)\n    val (i,j) = tupleToArgIndices(rows(row))\n    val sample = Cell(pos.s, i, j)\n    if (attempts == 0) {\n      println(\"Couldn't sample a negative cell for \" + pos)\n      sample\n    } else if (trainingData.contains(sample)) {\n      inner(attempts - 1)\n    } else sample\n  }\n  inner(100)\n}\n\n//the score of one cell\ndef score(t: Thetas.Term)(cell: Cells.Term): DoubleTerm =\n  t.relations(cell.s) dot t.pairs(cellToPairIx(cell))\n\n//training loss \ndef loss(t: Thetas.Term) = {\n  //we sample a positive cell, and memoize the result\n  val pos = mem(trainingData.sampleShuffled)\n  //based on the memoized positive cell, we sample a negative cell      which needs to be memoized because it will reappear several times\n  val neg = mem(pos.map(sampleNegCell))\n  log(sigm(score(t)(pos))) + log(sigm(-score(t)(neg))) \n}",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\n\",\"//all relations (structured and unstructured) that will become the columns of our data matrix\\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)\",\"//mapping from entity-pairs to their unique index\\nval pairToPairIx = rows.zipWithIndex.toMap\\n\\nval data = List(is_historian_at, is_professor_at, museum_at, teaches_history_at, employeeAt).map(_.map(pairToPairIx))\\n\\n//training tuples (s, ij)\\nval tuples = data.zipWithIndex.flatMap(t => t._1.map(pair => t._2 -> pair))\\n\\n//training triples (s, i, j)\\nval triples = tuples.map(t => t._1 -> tupleToArgIndices(rows(t._2))).map(t => (t._1, t._2._1, t._2._2))\",\"//visualization of the sparse data matrix\\nMatrix((0 until rows.length).map(row => (0 until cols.length).map(col => if (data(col).contains(row)) 1.0 else 0.0).toSeq).toSeq, rows.map(t => t._1+\\\",\\\"+t._2), cols.map(_.toString))\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><span class=\"asString String\">ISeq(8)(Cell(0,1,1),Cell(0,2,2),Cell(1,0,0),Cell(1,1,1),Cell(1,3,2),Cell(2,0,0),Cell(3,3,2),Cell(4,0,0))</span></div>"
    }
  }, {
    "id" : 7,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : " //learning parameters\nval init = Settings(Thetas.createRandomSetting(random.nextGaussian() * 0.1))\nval adaParams = AdaGradParameters(epochs = 100, learningRate = 0.1, initParams = init, delta = 0.1)\n\n//do the training (argmax is a term, so it needs to be evaluated to do the optimization)\nval thetaStar = argmax(Thetas)(t => loss(t).argmaxBy(Argmaxer.adaGrad(adaParams))).eval()",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\n\",\"//all relations (structured and unstructured) that will become the columns of our data matrix\\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)\",\"//mapping from entity-pairs to their unique index\\nval pairToPairIx = rows.zipWithIndex.toMap\\n\\nval data = List(is_historian_at, is_professor_at, museum_at, teaches_history_at, employeeAt).map(_.map(pairToPairIx))\\n\\n//training tuples (s, ij)\\nval tuples = data.zipWithIndex.flatMap(t => t._1.map(pair => t._2 -> pair))\\n\\n//training triples (s, i, j)\\nval triples = tuples.map(t => t._1 -> tupleToArgIndices(rows(t._2))).map(t => (t._1, t._2._1, t._2._2))\",\"//visualization of the sparse data matrix\\nMatrix((0 until rows.length).map(row => (0 until cols.length).map(col => if (data(col).contains(row)) 1.0 else 0.0).toSeq).toSeq, rows.map(t => t._1+\\\",\\\"+t._2), cols.map(_.toString))\",\"//the dimension of latent representations\\nval k = 10\\n\\nimplicit val random = new scala.util.Random(1l)\\n\\n//the domain of parameters\\n@domain case class Theta(relations: IndexedSeq[Vect], pairs: IndexedSeq[Vect])\\n\\n//the set of possible parameters\\nimplicit val Thetas = Theta.Values(Seqs(Vectors(k), cols.size), Seqs(Vectors(k), rows.size))\\n\\n//the class of cells\\n@domain case class Cell(s: Int, i: Int, j: Int)\\n\\n//the set of possible cells\\nimplicit val Cells = Cell.Values(Ints(0 until rows.length), Ints(0 until entities.length), Ints(0 until entities.length))\\n\\n//mapping cell argument indices to entity-pair index\\ndef cellToPairIx(term: Cells.Term) = term.map(c => argsIxToPairIx(c.i -> c.j))\\n\\n//mapping training data (s, i, j) to values of the Cells domain\\nval trainingData = triples.map(t => Cell(t._1, t._2, t._3)).toConst(Cells)\\n\\n//samples an unobserved cell for a given relation\\ndef sampleNegCell(pos: Cell): Cell = {\\n  def inner(attempts: Int): Cell = {\\n    val row = random.nextInt(rows.size)\\n    val (i,j) = tupleToArgIndices(rows(row))\\n    val sample = Cell(pos.s, i, j)\\n    if (attempts == 0) {\\n      println(\\\"Couldn't sample a negative cell for \\\" + pos)\\n      sample\\n    } else if (trainingData.contains(sample)) {\\n      inner(attempts - 1)\\n    } else sample\\n  }\\n  inner(100)\\n}\\n\\n//the score of one cell\\ndef score(t: Thetas.Term)(cell: Cells.Term): DoubleTerm =\\n  t.relations(cell.s) dot t.pairs(cellToPairIx(cell))\\n\\n//training loss \\ndef loss(t: Thetas.Term) = {\\n  //we sample a positive cell, and memoize the result\\n  val pos = mem(trainingData.sampleShuffled)\\n  //based on the memoized positive cell, we sample a negative cell      which needs to be memoized because it will reappear several times\\n  val neg = mem(pos.map(sampleNegCell))\\n  log(sigm(score(t)(pos))) + log(sigm(-score(t)(neg))) \\n}\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><div class=\"asProduct Theta\"><span class=\"typeName\">Theta</span>\n<ul class=\"fields\">\n  <li class=\"field\"><span class=\"fieldName\">relations</span> <span class=\"fieldValue\"><div class=\"asIterable Vector\"><span class=\"typeName\">Vector</span>\n    <ol start=\"0\" class=\"fields\">\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(-0.24740929408583512,-0.71580854411386,-0.22697078347793576,-0.7617572720568567,-0.27707449605423823,-0.11800997027716115,-1.3787763005519469,0.32820055237136286,-0.17188858265975746,0.3992879518306161)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(0.24502316057666598,0.0204268823846653,-0.7869270801790833,0.13040219627420715,0.5880014935552418,-0.014415295924189084,0.013122749406569625,-0.24716254437688448,-0.22880435582972536,-0.022013219944387475)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(0.18914922300939,0.6948997496138735,0.35520795514430853,-0.07761274457535067,0.5994402892873489,-0.8521785656180569,-0.9101536823972687,-0.3645452813081098,0.019580227946562865,-0.39032951572578267)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(-0.596623867675577,-0.3221162742524056,-0.1542229659713245,0.7436520203026813,-0.10467741370811007,0.10477361730913926,-0.06807919034483345,-0.8580240403058653,-1.047845871240634,-0.7676880554159645)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(0.23419642333499996,0.4695105829591931,0.151514802981596,0.2512997985560394,0.832773749218279,-1.0440717575320555,-0.7785656716103881,-0.5523104947678473,-0.11861696772144646,-0.2899379829946588)</span></li>\n    </ol>\n</div></span></li>\n  <li class=\"field\"><span class=\"fieldName\">pairs</span> <span class=\"fieldValue\"><div class=\"asIterable Vector\"><span class=\"typeName\">Vector</span>\n    <ol start=\"0\" class=\"fields\">\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(0.6252849891822659,0.9612200336388806,0.21207170271539352,0.20756163455838958,0.6908183348573369,-0.4701824397311514,0.5543020152804454,0.08722778714248888,0.7043059935380395,0.04329618943372196)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(0.2622608475004109,-0.4619223888400405,-0.6899069524557483,-0.5484148401215997,-0.1370701454598943,0.7343113102156827,0.18085534856799027,0.6397291096862908,0.3512001153546165,0.7557367213840848)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(-0.1732890402867916,-0.2230246185518236,0.9584025094493348,-0.46433348681977715,-1.0689689885136018,0.699283921523725,0.326785278629459,0.8611491680283917,0.9052970370231009,0.4871608950927717)</span></li>\n      <li class=\"fieldValue\"><span class=\"asString String\">Tensor1(-0.14724090144242075,-0.07457993883820319,-0.23154517442869688,0.8144463739360078,-0.3202799120460297,0.9486852824138347,1.3843258459212207,-0.34988924005878735,-0.3557251101247829,-0.39298662892366515)</span></li>\n    </ol>\n</div></span></li>\n</ul>\n</div></div>"
    }
  }, {
    "id" : 8,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val thetaLearned: Thetas.Term = Thetas.Const(thetaStar)\n\nval probFun = fun(Cells) { x => sigm(score(thetaLearned)(x)) }\n\ndef predict(s: Int, i: Int, j: Int): Double = probFun(Cell(s, i, j))\n\ndef predict(s: Int, ij: Int): Double = {\n    val (i,j) = tupleToArgIndices(rows(ij))\n    predict(s, i, j)\n}\n\nMatrix((0 until rows.length).map(row => (0 until cols.length).map(col => predict(col,row)).toSeq).toSeq, rows.map(t => t._1+\",\"+t._2), cols.map(_.toString))\n\n//tuples.map(t => predict(t._1,t._2))",
      "extraFields" : {
        "aggregatedCells" : "[\"//all entities\\nimplicit def entities = List('Cambridge, 'UCL, 'Harvard, 'Petrie, 'Ferguson, 'Andrew, 'Trevelyan)\\n\\n//a Freebase relation\\ndef employeeAt = Set('Petrie -> 'UCL)\\n\\n//visualization of knowledge graph\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y))\",\"//some surface form relations\\ndef is_historian_at = Set('Ferguson -> 'Harvard, 'Trevelyan -> 'Cambridge)\\ndef is_professor_at = Set('Petrie -> 'UCL, 'Ferguson -> 'Harvard, 'Andrew -> 'Cambridge)\\ndef museum_at = Set('Petrie -> 'UCL)\\ndef teaches_history_at = Set('Andrew -> 'Cambridge)\\n\\n//visualization of knowledge graph and surface forms\\nGraph.fromPreds[Symbol](entities, (x,y) => employeeAt(x -> y) || is_historian_at(x -> y) || is_professor_at(x -> y) || museum_at(x -> y) || teaches_history_at(x -> y))\",\"//all entity-pairs that will become the rows of our data matrix\\nval rows = (employeeAt ++ is_historian_at ++ is_professor_at ++ museum_at ++ teaches_history_at).toList\\n\\n//convenience data structures\\n//mapping from entities that appear as first arguments to their index\\nval arg1s = rows.map(_._1).distinct.zipWithIndex.toMap\\n\\n//mapping from entities that appear as second arguments to their index\\nval arg2s = rows.map(_._2).distinct.zipWithIndex.toMap\\n\\n//mapping from tuples to their argument indices\\nval tupleToArgIndices = rows.map(t => (t._1 -> t._2) -> (arg1s(t._1) -> arg2s(t._2))).toMap\\n\\n//mapping from argument indices to entity-pair index\\nval argsIxToPairIx = rows.map(tupleToArgIndices).zipWithIndex.toMap\\n\",\"//all relations (structured and unstructured) that will become the columns of our data matrix\\nval cols = List('is_historian_at, 'is_professor_at, 'museum_at, 'teaches_history_at, 'employeeAt)\",\"//mapping from entity-pairs to their unique index\\nval pairToPairIx = rows.zipWithIndex.toMap\\n\\nval data = List(is_historian_at, is_professor_at, museum_at, teaches_history_at, employeeAt).map(_.map(pairToPairIx))\\n\\n//training tuples (s, ij)\\nval tuples = data.zipWithIndex.flatMap(t => t._1.map(pair => t._2 -> pair))\\n\\n//training triples (s, i, j)\\nval triples = tuples.map(t => t._1 -> tupleToArgIndices(rows(t._2))).map(t => (t._1, t._2._1, t._2._2))\",\"//visualization of the sparse data matrix\\nMatrix((0 until rows.length).map(row => (0 until cols.length).map(col => if (data(col).contains(row)) 1.0 else 0.0).toSeq).toSeq, rows.map(t => t._1+\\\",\\\"+t._2), cols.map(_.toString))\",\"//the dimension of latent representations\\nval k = 10\\n\\nimplicit val random = new scala.util.Random(1l)\\n\\n//the domain of parameters\\n@domain case class Theta(relations: IndexedSeq[Vect], pairs: IndexedSeq[Vect])\\n\\n//the set of possible parameters\\nimplicit val Thetas = Theta.Values(Seqs(Vectors(k), cols.size), Seqs(Vectors(k), rows.size))\\n\\n//the class of cells\\n@domain case class Cell(s: Int, i: Int, j: Int)\\n\\n//the set of possible cells\\nimplicit val Cells = Cell.Values(Ints(0 until rows.length), Ints(0 until entities.length), Ints(0 until entities.length))\\n\\n//mapping cell argument indices to entity-pair index\\ndef cellToPairIx(term: Cells.Term) = term.map(c => argsIxToPairIx(c.i -> c.j))\\n\\n//mapping training data (s, i, j) to values of the Cells domain\\nval trainingData = triples.map(t => Cell(t._1, t._2, t._3)).toConst(Cells)\\n\\n//samples an unobserved cell for a given relation\\ndef sampleNegCell(pos: Cell): Cell = {\\n  def inner(attempts: Int): Cell = {\\n    val row = random.nextInt(rows.size)\\n    val (i,j) = tupleToArgIndices(rows(row))\\n    val sample = Cell(pos.s, i, j)\\n    if (attempts == 0) {\\n      println(\\\"Couldn't sample a negative cell for \\\" + pos)\\n      sample\\n    } else if (trainingData.contains(sample)) {\\n      inner(attempts - 1)\\n    } else sample\\n  }\\n  inner(100)\\n}\\n\\n//the score of one cell\\ndef score(t: Thetas.Term)(cell: Cells.Term): DoubleTerm =\\n  t.relations(cell.s) dot t.pairs(cellToPairIx(cell))\\n\\n//training loss \\ndef loss(t: Thetas.Term) = {\\n  //we sample a positive cell, and memoize the result\\n  val pos = mem(trainingData.sampleShuffled)\\n  //based on the memoized positive cell, we sample a negative cell      which needs to be memoized because it will reappear several times\\n  val neg = mem(pos.map(sampleNegCell))\\n  log(sigm(score(t)(pos))) + log(sigm(-score(t)(neg))) \\n}\",\" //learning parameters\\nval init = Settings(Thetas.createRandomSetting(random.nextGaussian() * 0.1))\\nval adaParams = AdaGradParameters(epochs = 100, learningRate = 0.1, initParams = init, delta = 0.1)\\n\\n//do the training (argmax is a term, so it needs to be evaluated to do the optimization)\\nval thetaStar = argmax(Thetas)(t => loss(t).argmaxBy(Argmaxer.adaGrad(adaParams))).eval()\"]"
      },
      "outputFormat" : "<div class=\"string-result\"><table class=\"matrix\">\n  <thead>\n  <tr class=\"matrixRow\">\n  <th></th>\n    <th class=\"rotate\"><div><span>'is_historian_at</span></div></th>\n    <th class=\"rotate\"><div><span>'is_professor_at</span></div></th>\n    <th class=\"rotate\"><div><span>'museum_at</span></div></th>\n    <th class=\"rotate\"><div><span>'teaches_history_at</span></div></th>\n    <th class=\"rotate\"><div><span>'employeeAt</span></div></th>\n  </tr>\n  </thead>\n  <tbody>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Petrie,'UCL</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:0.068970\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.637578\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.873873\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.139745\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.885790\"></td>\n  </tr>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Ferguson,'Harvard</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:0.843093\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.610366\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.090601\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.112243\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.067775\"></td>\n  </tr>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Trevelyan,'Cambridge</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:0.684650\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.082141\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.095934\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.045750\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.000000\"></td>\n  </tr>\n  <tr class=\"matrixRow\">\n    <th><div><span>'Andrew,'Cambridge</span></div></th>\n    <td class=\"matrixCell\" style=\"opacity:0.007296\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.629467\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.046300\"></td>\n    <td class=\"matrixCell\" style=\"opacity:1.000000\"></td>\n    <td class=\"matrixCell\" style=\"opacity:0.088013\"></td>\n  </tr>\n  </tbody>\n</table></div>"
    }
  } ],
  "config" : { }
}
